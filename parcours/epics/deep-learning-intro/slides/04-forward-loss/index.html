<!DOCTYPE html>
<html lang="fr" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forward & Loss - Deep Learning</title>

    <link rel="stylesheet" href="../../../../../lib/theme.css">
    <link rel="stylesheet" href="../../_shared/deep-learning.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="module">
        import { initSlide, initGlossary, sendTOC, setupScrollHandler } from '../../../../../parcours/_shared/slide-utils.js';
        initSlide();
        initGlossary();
        setupScrollHandler();
        sendTOC([
            { id: 'forward', label: 'Propagation Avant', icon: '‚û°Ô∏è' },
            { id: 'loss', label: 'Mesurer l\'Erreur', icon: 'üìè' },
        ]);
    </script>
</head>
<body class="antialiased selection:bg-blue-500 selection:text-white">

    <main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">

        <!-- FORWARD PROPAGATION -->
        <section id="forward" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">‚û°Ô∏è</span>
                <h2 class="text-3xl font-bold dl-text-primary">La Propagation Avant</h2>
            </div>

            <div class="prose-content dl-text-secondary">

                <!-- ACCROCHE : LE VOYAGE DE LA DONN√âE -->
                <p class="text-lg mb-6 dl-text-primary font-medium">
                    La propagation avant est le processus par lequel une donn√©e brute traverse le r√©seau pour devenir une pr√©diction. C'est une suite de <strong>fonctions compos√©es</strong> : la sortie d'une couche devient l'entr√©e de la suivante. Si vous savez calculer \(f(g(x))\), vous comprenez d√©j√† la propagation avant.
                </p>

                <!-- LES TROIS PRINCIPES -->
                <div class="grid md:grid-cols-3 gap-4 my-8">
                    <div class="dl-card p-4 rounded-xl border">
                        <div class="text-2xl mb-2">‚û°Ô∏è</div>
                        <h4 class="font-bold text-blue-400 mb-2">Flux Unidirectionnel</h4>
                        <p class="text-sm dl-text-muted">
                            L'information "coule" de gauche √† droite, de l'entr√©e vers la sortie, sans jamais revenir en arri√®re √† cette √©tape.
                        </p>
                    </div>
                    <div class="dl-card p-4 rounded-xl border">
                        <div class="text-2xl mb-2">üîÑ</div>
                        <h4 class="font-bold text-purple-400 mb-2">Transformation par √âtapes</h4>
                        <p class="text-sm dl-text-muted">
                            √Ä chaque couche \(l\), deux op√©rations : une somme pond√©r√©e \(z\), puis une activation \(a\) qui introduit la non-lin√©arit√©.
                        </p>
                    </div>
                    <div class="dl-card p-4 rounded-xl border">
                        <div class="text-2xl mb-2">üíæ</div>
                        <h4 class="font-bold text-green-400 mb-2">M√©morisation Strat√©gique</h4>
                        <p class="text-sm dl-text-muted">
                            Le r√©seau stocke les valeurs interm√©diaires. Sans ce cache, la r√©tropropagation serait extr√™mement lente.
                        </p>
                    </div>
                </div>

                <h3 class="text-xl font-bold dl-text-primary mt-10 mb-4">La cha√Æne de sculpture</h3>

                <p class="mb-4">
                    Imaginez un atelier o√π une dizaine d'artisans travaillent en cha√Æne sur un bloc de marbre brut. Le premier re√ßoit la mati√®re premi√®re et effectue les coupes grossi√®res pour d√©gager la forme g√©n√©rale. Il passe ensuite sa cr√©ation au suivant, qui affine les contours, ajoute des d√©tails, ajuste les proportions.
                </p>

                <div class="concept-box my-6">
                    <div class="grid md:grid-cols-3 gap-4 text-center">
                        <div>
                            <div class="text-3xl mb-2">ü™®</div>
                            <p class="text-sm font-bold text-cyan-400">Entr√©e \(a^{[0]}\)</p>
                            <p class="text-xs dl-text-muted">Le marbre brut</p>
                            <p class="text-xs dl-text-secondary">La donn√©e arrive au premier artisan</p>
                        </div>
                        <div>
                            <div class="text-3xl mb-2">‚öíÔ∏è</div>
                            <p class="text-sm font-bold text-purple-400">Couches cach√©es</p>
                            <p class="text-xs dl-text-muted">Les artisans</p>
                            <p class="text-xs dl-text-secondary">Chaque couche affine la forme</p>
                        </div>
                        <div>
                            <div class="text-3xl mb-2">üóø</div>
                            <p class="text-sm font-bold text-green-400">Sortie \(\hat{y}\)</p>
                            <p class="text-xs dl-text-muted">L'≈ìuvre finale</p>
                            <p class="text-xs dl-text-secondary">La pr√©diction sort de l'atelier</p>
                        </div>
                    </div>
                </div>

                <p class="mb-6 text-sm dl-text-muted italic">
                    Les premi√®res couches d√©tectent des structures grossi√®res ‚Äî contours, textures basiques. Les couches interm√©diaires reconnaissent des formes plus complexes. Les derni√®res polissent les d√©tails et identifient des concepts de haut niveau. Cette cascade de transformations construit une <strong>hi√©rarchie de repr√©sentations</strong>.
                </p>

                <!-- FORMULES -->
                <h3 class="text-xl font-bold dl-text-primary mt-10 mb-4">Les formules</h3>

                <p class="mb-4">
                    Pour chaque couche \(l\) du r√©seau, on applique deux op√©rations :
                </p>

                <div class="math-block">
                    <p class="text-sm dl-text-muted mb-2">1. La somme pond√©r√©e (pr√©-activation) :</p>
                    $$ z^{[l]} = W^{[l]} \cdot a^{[l-1]} + b^{[l]} $$
                    <p class="text-sm dl-text-muted mb-2 mt-4">2. L'activation :</p>
                    $$ a^{[l]} = \sigma(z^{[l]}) $$
                </div>

                <p class="mb-6">
                    On part de \(a^{[0]} = x\) (l'entr√©e) et on r√©p√®te ce processus jusqu'√† obtenir la pr√©diction finale \(\hat{y} = a^{[L]}\).
                </p>

                <!-- PSEUDO-CODE AM√âLIOR√â -->
                <h3 class="text-xl font-bold dl-text-primary mt-10 mb-4">Pseudo-code</h3>

                <div class="dl-card rounded-xl border overflow-hidden mb-8">
                    <div class="bg-slate-800 px-4 py-2 text-xs text-slate-400 border-b border-slate-700">
                        forward.py
                    </div>
                    <pre class="p-4 text-sm overflow-x-auto"><code class="text-slate-300"><span class="text-slate-500"># Initialisation avec l'entr√©e (a[0] = x)</span>
<span class="text-purple-400">activation_actuelle</span> = x

<span class="text-slate-500"># On parcourt chaque couche l du r√©seau</span>
<span class="text-pink-400">pour</span> l <span class="text-pink-400">de</span> <span class="text-cyan-400">1</span> <span class="text-pink-400">√†</span> L:
    <span class="text-slate-500"># 1. Calcul de la somme pond√©r√©e z[l] = W[l] * a[l-1] + b[l]</span>
    <span class="text-purple-400">z</span> = produit_matriciel(poids[l], activation_actuelle) + biais[l]

    <span class="text-slate-500"># 2. Calcul de l'activation a[l] = sigma(z[l])</span>
    <span class="text-purple-400">activation_actuelle</span> = fonction_activation(z)

    <span class="text-slate-500"># Sauvegarde de z et a pour la future r√©tropropagation</span>
    stocker_intermediaire(z, activation_actuelle)

<span class="text-slate-500"># Le r√©sultat final est la pr√©diction</span>
<span class="text-purple-400">y_chapeau</span> = activation_actuelle</code></pre>
                </div>

                <div class="warning-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">üí°</span>
                        <div>
                            <h4 class="font-bold text-yellow-500 mb-2">Pourquoi c'est "trivial mais fondamental"</h4>
                            <p class="dl-text-secondary text-sm">
                                La propagation avant n'est qu'une √©valuation de fonction compos√©e ‚Äî rien de nouveau math√©matiquement. Ce qui est r√©volutionnaire, c'est de l'appliquer √† des <strong>graphes de calcul</strong> de millions de param√®tres, et de <strong>stocker les interm√©diaires</strong> pour la phase d'apprentissage.
                            </p>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- LOSS FUNCTION -->
        <section id="loss" class="mb-16 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">üìè</span>
                <h2 class="text-3xl font-bold dl-text-primary">Mesurer l'Erreur</h2>
            </div>

            <div class="prose-content dl-text-secondary">

                <p class="text-lg mb-6 dl-text-primary font-medium">
                    La propagation avant trace la trajectoire du r√©seau. La fonction de perte mesure la distance qui le s√©pare de la destination. Ces deux informations compl√©mentaires ‚Äî <em>o√π je suis</em> et <em>√† quel point je me trompe</em> ‚Äî sont essentielles pour guider l'apprentissage.
                </p>

                <h3 class="text-xl font-bold dl-text-primary mt-8 mb-4">Le navigateur dans la brume</h3>

                <p class="mb-4">
                    Imaginez un navigateur du XVIIIe si√®cle tentant d'atteindre une √Æle lointaine sans GPS, √©quip√© uniquement d'un sextant et de cartes imparfaites. √Ä chaque point de sa travers√©e, il mesure sa position actuelle, calcule la distance qui le s√©pare de sa destination, puis ajuste son cap en cons√©quence.
                </p>

                <p class="mb-4">
                    Cette mesure d'√©cart entre <em>"o√π je suis"</em> et <em>"o√π je veux √™tre"</em> est absolument cruciale : sans elle, le navigateur voguerait √† l'aveugle. Plus l'√©cart est grand, plus la correction doit √™tre significative ; plus il diminue, plus les ajustements deviennent subtils.
                </p>

                <p class="mb-6">
                    La <strong>fonction de perte</strong> joue exactement ce r√¥le. Elle transforme la qualit√© des pr√©dictions en un <strong>nombre unique</strong> : plus la perte est √©lev√©e, plus le r√©seau se trompe. C'est ce signal qui guidera la correction des poids lors de la r√©tropropagation.
                </p>

                <!-- VISUALISATION INTERACTIVE DES LOSS FUNCTIONS -->
                <h3 class="text-xl font-bold dl-text-primary mt-10 mb-4">Comparer les fonctions de perte</h3>

                <p class="mb-4">
                    Cliquez sur une fonction pour voir sa courbe et comprendre son comportement :
                </p>

                <div class="my-6 p-4 dl-card rounded-xl border">
                    <!-- S√©lecteur de loss -->
                    <div class="flex flex-wrap justify-center gap-2 mb-4">
                        <button id="btnMSE" class="loss-btn px-4 py-2 rounded-lg text-sm font-medium transition-all border-2 border-orange-500 bg-orange-500/20 text-orange-400">
                            MSE
                        </button>
                        <button id="btnMAE" class="loss-btn px-4 py-2 rounded-lg text-sm font-medium transition-all border-2 border-cyan-500/30 bg-transparent text-cyan-400 hover:border-cyan-500 hover:bg-cyan-500/20">
                            MAE
                        </button>
                        <button id="btnHuber" class="loss-btn px-4 py-2 rounded-lg text-sm font-medium transition-all border-2 border-green-500/30 bg-transparent text-green-400 hover:border-green-500 hover:bg-green-500/20">
                            Huber
                        </button>
                        <button id="btnCrossEntropy" class="loss-btn px-4 py-2 rounded-lg text-sm font-medium transition-all border-2 border-purple-500/30 bg-transparent text-purple-400 hover:border-purple-500 hover:bg-purple-500/20">
                            Cross-Entropy
                        </button>
                    </div>

                    <!-- Info sur la loss s√©lectionn√©e -->
                    <div id="lossInfo" class="text-center mb-4">
                        <h4 id="lossTitle" class="font-bold text-orange-400 text-lg">MSE ‚Äî Erreur Quadratique Moyenne</h4>
                        <p id="lossFormula" class="font-mono text-sm dl-text-muted my-2">\( L = \frac{1}{2}(y - \hat{y})^2 \)</p>
                        <p id="lossDescription" class="text-sm dl-text-secondary max-w-lg mx-auto">
                            P√©nalise fortement les grandes erreurs (quadratiquement). Id√©ale pour la r√©gression, mais sensible aux outliers.
                        </p>
                    </div>

                    <!-- Canvas de visualisation -->
                    <div class="flex flex-col items-center">
                        <canvas id="lossCanvas" width="500" height="280" class="rounded-lg" style="max-width: 500px; width: 100%;"></canvas>
                        <div class="flex items-center gap-3 mt-3">
                            <label class="text-sm dl-text-secondary">Cible y =</label>
                            <input type="range" id="targetY" min="-1" max="1" step="0.1" value="0" class="w-32">
                            <span id="targetYValue" class="font-mono text-cyan-400 w-12">0.0</span>
                        </div>
                        <p class="text-center text-xs dl-text-muted mt-2">Survolez la courbe pour voir les valeurs ‚Ä¢ D√©placez le curseur pour changer la cible</p>
                    </div>
                </div>

                <script>
                (function() {
                    const canvas = document.getElementById('lossCanvas');
                    const ctx = canvas.getContext('2d');
                    const slider = document.getElementById('targetY');
                    const valueDisplay = document.getElementById('targetYValue');
                    const W = canvas.width, H = canvas.height;
                    const margin = { top: 30, right: 30, bottom: 40, left: 50 };
                    const plotW = W - margin.left - margin.right;
                    const plotH = H - margin.top - margin.bottom;

                    // √âtat
                    let currentLoss = 'mse';
                    let mouseX = null;
                    const huberDelta = 0.5;

                    // Fonctions de perte
                    const lossFunctions = {
                        mse: {
                            fn: (y, yHat) => 0.5 * Math.pow(y - yHat, 2),
                            color: '#f97316',
                            title: 'MSE ‚Äî Erreur Quadratique Moyenne',
                            formula: '\\( L = \\frac{1}{2}(y - \\hat{y})^2 \\)',
                            description: 'P√©nalise fortement les grandes erreurs (quadratiquement). Id√©ale pour la r√©gression, mais sensible aux outliers.',
                            yMax: 2.5,
                            xRange: [-1.5, 1.5]
                        },
                        mae: {
                            fn: (y, yHat) => Math.abs(y - yHat),
                            color: '#22d3ee',
                            title: 'MAE ‚Äî Erreur Absolue Moyenne',
                            formula: '\\( L = |y - \\hat{y}| \\)',
                            description: 'Traite toutes les erreurs de fa√ßon √©quitable (lin√©airement). Plus robuste aux outliers que MSE.',
                            yMax: 2.5,
                            xRange: [-1.5, 1.5]
                        },
                        huber: {
                            fn: (y, yHat) => {
                                const diff = Math.abs(y - yHat);
                                if (diff <= huberDelta) {
                                    return 0.5 * diff * diff;
                                } else {
                                    return huberDelta * (diff - 0.5 * huberDelta);
                                }
                            },
                            color: '#22c55e',
                            title: 'Huber ‚Äî Perte Hybride',
                            formula: '\\( L = \\begin{cases} \\frac{1}{2}(y-\\hat{y})^2 & |y-\\hat{y}| \\leq \\delta \\\\ \\delta(|y-\\hat{y}| - \\frac{\\delta}{2}) & \\text{sinon} \\end{cases} \\)',
                            description: 'Quadratique pr√®s de 0 (gradients lisses), lin√©aire loin (robustesse). Le meilleur des deux mondes avec Œ¥=' + huberDelta + '.',
                            yMax: 2.5,
                            xRange: [-1.5, 1.5]
                        },
                        crossentropy: {
                            fn: (y, yHat) => {
                                // Pour y=1 (classe positive) : -log(yHat)
                                // Pour y=0 (classe n√©gative) : -log(1-yHat)
                                // Ici on montre -log(yHat) pour y=1
                                const eps = 1e-7;
                                const p = Math.max(eps, Math.min(1 - eps, (yHat + 1) / 2)); // map [-1,1] to [0,1]
                                return -Math.log(p);
                            },
                            color: '#a855f7',
                            title: 'Cross-Entropy ‚Äî Classification',
                            formula: '\\( L = -\\log(\\hat{y}) \\)',
                            description: 'Pour les probabilit√©s (0 √† 1). Punit exponentiellement les pr√©dictions confiantes mais fausses. Ici : -log(≈∑) pour y=1.',
                            yMax: 5,
                            xRange: [-1, 1]
                        }
                    };

                    const toCanvasX = (x, xMin, xMax) => margin.left + (x - xMin) / (xMax - xMin) * plotW;
                    const toCanvasY = (y, yMax) => margin.top + (yMax - y) / yMax * plotH;
                    const fromCanvasX = (cx, xMin, xMax) => xMin + (cx - margin.left) / plotW * (xMax - xMin);

                    function updateLossInfo() {
                        const loss = lossFunctions[currentLoss];
                        document.getElementById('lossTitle').textContent = loss.title;
                        document.getElementById('lossTitle').style.color = loss.color;
                        document.getElementById('lossFormula').innerHTML = loss.formula;
                        document.getElementById('lossDescription').textContent = loss.description;

                        // Re-render MathJax
                        if (window.MathJax) {
                            MathJax.typesetPromise([document.getElementById('lossFormula')]);
                        }
                    }

                    function updateButtons() {
                        const buttons = {
                            mse: document.getElementById('btnMSE'),
                            mae: document.getElementById('btnMAE'),
                            huber: document.getElementById('btnHuber'),
                            crossentropy: document.getElementById('btnCrossEntropy')
                        };
                        const colors = {
                            mse: 'orange',
                            mae: 'cyan',
                            huber: 'green',
                            crossentropy: 'purple'
                        };

                        Object.keys(buttons).forEach(key => {
                            const btn = buttons[key];
                            const color = colors[key];
                            if (key === currentLoss) {
                                btn.className = `loss-btn px-4 py-2 rounded-lg text-sm font-medium transition-all border-2 border-${color}-500 bg-${color}-500/20 text-${color}-400`;
                            } else {
                                btn.className = `loss-btn px-4 py-2 rounded-lg text-sm font-medium transition-all border-2 border-${color}-500/30 bg-transparent text-${color}-400 hover:border-${color}-500 hover:bg-${color}-500/20`;
                            }
                        });
                    }

                    function draw() {
                        const targetY = parseFloat(slider.value);
                        valueDisplay.textContent = targetY.toFixed(1);

                        const loss = lossFunctions[currentLoss];
                        const [xMin, xMax] = loss.xRange;
                        const yMax = loss.yMax;

                        const isDark = document.documentElement.classList.contains('dark');
                        const bgColor = isDark ? '#1a1a2e' : '#f8fafc';
                        const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                        const axisColor = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                        const textColor = isDark ? '#94a3b8' : '#64748b';

                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, W, H);

                        // Grille
                        ctx.strokeStyle = gridColor;
                        ctx.lineWidth = 1;
                        for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x += 0.5) {
                            ctx.beginPath();
                            ctx.moveTo(toCanvasX(x, xMin, xMax), margin.top);
                            ctx.lineTo(toCanvasX(x, xMin, xMax), H - margin.bottom);
                            ctx.stroke();
                        }
                        for (let y = 0; y <= yMax; y += 0.5) {
                            ctx.beginPath();
                            ctx.moveTo(margin.left, toCanvasY(y, yMax));
                            ctx.lineTo(W - margin.right, toCanvasY(y, yMax));
                            ctx.stroke();
                        }

                        // Axe vertical √† la position de la cible (pour MSE, MAE, Huber)
                        if (currentLoss !== 'crossentropy') {
                            ctx.strokeStyle = '#22d3ee';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(toCanvasX(targetY, xMin, xMax), margin.top);
                            ctx.lineTo(toCanvasX(targetY, xMin, xMax), H - margin.bottom);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }

                        // Axes
                        ctx.strokeStyle = axisColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(margin.left, toCanvasY(0, yMax));
                        ctx.lineTo(W - margin.right, toCanvasY(0, yMax));
                        ctx.stroke();

                        // Labels
                        ctx.fillStyle = textColor;
                        ctx.font = '11px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('≈∑ (pr√©diction)', W / 2, H - 5);
                        ctx.fillText(xMin.toString(), toCanvasX(xMin, xMin, xMax), H - margin.bottom + 18);
                        ctx.fillText('0', toCanvasX(0, xMin, xMax), H - margin.bottom + 18);
                        ctx.fillText(xMax.toString(), toCanvasX(xMax, xMin, xMax), H - margin.bottom + 18);
                        ctx.textAlign = 'right';
                        ctx.fillText('L (perte)', margin.left - 5, margin.top - 10);

                        for (let y = 1; y <= yMax; y++) {
                            ctx.fillText(y.toString(), margin.left - 8, toCanvasY(y, yMax) + 4);
                        }

                        // Courbe de perte
                        ctx.strokeStyle = loss.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        let started = false;
                        for (let px = margin.left; px <= W - margin.right; px++) {
                            const yHat = fromCanvasX(px, xMin, xMax);
                            const lossVal = loss.fn(targetY, yHat);
                            const py = toCanvasY(Math.min(lossVal, yMax), yMax);
                            if (py >= margin.top && py <= H - margin.bottom) {
                                if (!started) { ctx.moveTo(px, py); started = true; }
                                else ctx.lineTo(px, py);
                            }
                        }
                        ctx.stroke();

                        // Point minimum (pour MSE, MAE, Huber)
                        if (currentLoss !== 'crossentropy') {
                            ctx.fillStyle = '#22c55e';
                            ctx.beginPath();
                            ctx.arc(toCanvasX(targetY, xMin, xMax), toCanvasY(0, yMax), 8, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = textColor;
                            ctx.font = 'bold 10px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText('y=' + targetY.toFixed(1), toCanvasX(targetY, xMin, xMax), H - margin.bottom + 32);
                        }

                        // Point sur la courbe si souris
                        if (mouseX !== null && mouseX >= margin.left && mouseX <= W - margin.right) {
                            const yHat = fromCanvasX(mouseX, xMin, xMax);
                            const lossVal = loss.fn(targetY, yHat);

                            // Ligne verticale
                            ctx.strokeStyle = '#ef4444';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([4, 4]);
                            ctx.beginPath();
                            ctx.moveTo(mouseX, toCanvasY(0, yMax));
                            ctx.lineTo(mouseX, toCanvasY(Math.min(lossVal, yMax), yMax));
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Point
                            ctx.fillStyle = '#ef4444';
                            ctx.beginPath();
                            ctx.arc(mouseX, toCanvasY(Math.min(lossVal, yMax), yMax), 6, 0, Math.PI * 2);
                            ctx.fill();

                            // Tooltip
                            const tooltipX = mouseX > W * 0.7 ? mouseX - 120 : mouseX + 15;
                            ctx.fillStyle = isDark ? 'rgba(30, 41, 59, 0.95)' : 'rgba(255, 255, 255, 0.95)';
                            ctx.strokeStyle = axisColor;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.roundRect(tooltipX, margin.top, 105, 50, 5);
                            ctx.fill();
                            ctx.stroke();

                            ctx.font = 'bold 11px monospace';
                            ctx.textAlign = 'left';
                            ctx.fillStyle = textColor;
                            ctx.fillText(`≈∑ = ${yHat.toFixed(2)}`, tooltipX + 8, margin.top + 18);
                            ctx.fillStyle = loss.color;
                            ctx.fillText(`L = ${lossVal.toFixed(3)}`, tooltipX + 8, margin.top + 35);
                        }

                        // Titre du graphique
                        ctx.font = 'bold 12px sans-serif';
                        ctx.fillStyle = loss.color;
                        ctx.textAlign = 'left';
                        ctx.fillText(loss.title.split(' ‚Äî ')[0], margin.left, margin.top - 10);
                    }

                    // Event listeners pour les boutons
                    document.getElementById('btnMSE').addEventListener('click', () => {
                        currentLoss = 'mse';
                        updateButtons();
                        updateLossInfo();
                        draw();
                    });
                    document.getElementById('btnMAE').addEventListener('click', () => {
                        currentLoss = 'mae';
                        updateButtons();
                        updateLossInfo();
                        draw();
                    });
                    document.getElementById('btnHuber').addEventListener('click', () => {
                        currentLoss = 'huber';
                        updateButtons();
                        updateLossInfo();
                        draw();
                    });
                    document.getElementById('btnCrossEntropy').addEventListener('click', () => {
                        currentLoss = 'crossentropy';
                        updateButtons();
                        updateLossInfo();
                        draw();
                    });

                    slider.addEventListener('input', draw);
                    canvas.addEventListener('mousemove', e => {
                        const rect = canvas.getBoundingClientRect();
                        mouseX = (e.clientX - rect.left) * (W / rect.width);
                        draw();
                    });
                    canvas.addEventListener('mouseleave', () => { mouseX = null; draw(); });
                    new MutationObserver(draw).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });

                    updateButtons();
                    draw();
                })();
                </script>

                <!-- TABLEAU R√âCAPITULATIF -->
                <h3 class="text-xl font-bold dl-text-primary mt-10 mb-4">Choisir la bonne fonction de perte</h3>

                <p class="mb-4">
                    Le choix de la fonction de perte est <strong>crucial</strong> car elle d√©finit ce que le r√©seau va optimiser ‚Äî et donc ce qu'il va apprendre.
                </p>

                <div class="overflow-x-auto my-6">
                    <table class="w-full text-sm border-collapse">
                        <thead>
                            <tr class="border-b border-slate-600">
                                <th class="text-left py-3 px-2 dl-text-primary">Fonction</th>
                                <th class="text-left py-3 px-2 dl-text-primary">Usage</th>
                                <th class="text-left py-3 px-2 dl-text-primary">Avantage</th>
                                <th class="text-left py-3 px-2 dl-text-primary">Inconv√©nient</th>
                            </tr>
                        </thead>
                        <tbody class="dl-text-secondary">
                            <tr class="border-b border-slate-700">
                                <td class="py-3 px-2 font-bold text-orange-400">MSE</td>
                                <td class="py-3 px-2">R√©gression</td>
                                <td class="py-3 px-2">P√©nalise fortement les grandes erreurs</td>
                                <td class="py-3 px-2 text-yellow-500">Sensible aux outliers</td>
                            </tr>
                            <tr class="border-b border-slate-700">
                                <td class="py-3 px-2 font-bold text-cyan-400">MAE</td>
                                <td class="py-3 px-2">R√©gression robuste</td>
                                <td class="py-3 px-2">Robuste aux outliers</td>
                                <td class="py-3 px-2 text-yellow-500">Gradient constant (convergence plus lente)</td>
                            </tr>
                            <tr class="border-b border-slate-700">
                                <td class="py-3 px-2 font-bold text-green-400">Huber</td>
                                <td class="py-3 px-2">R√©gression hybride</td>
                                <td class="py-3 px-2">Meilleur des deux mondes</td>
                                <td class="py-3 px-2 text-yellow-500">Hyperparam√®tre Œ¥ √† r√©gler</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-2 font-bold text-purple-400">Cross-Entropy</td>
                                <td class="py-3 px-2">Classification</td>
                                <td class="py-3 px-2">Adapt√© aux probabilit√©s</td>
                                <td class="py-3 px-2 text-yellow-500">Pas pour la r√©gression</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="warning-box mt-8">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">‚ö†Ô∏è</span>
                        <div>
                            <h4 class="font-bold text-yellow-500 mb-2">Le choix de la loss d√©finit l'apprentissage</h4>
                            <p class="dl-text-secondary text-sm">
                                Utiliser MSE pour de la classification donne des gradients instables. Utiliser Cross-Entropy pour de la r√©gression n'a pas de sens math√©matique. La fonction de perte doit <strong>refl√©ter ce qu'on veut vraiment optimiser</strong> ‚Äî c'est elle qui guide 100% de l'apprentissage.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- CONCLUSION -->
                <div class="concept-box mt-8">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">üéØ</span>
                        <div>
                            <h4 class="font-bold text-blue-400 mb-2">L'objectif de l'entra√Ænement</h4>
                            <p class="dl-text-secondary text-sm">
                                Trouver les valeurs de poids \(W\) et biais \(b\) qui <strong>minimisent</strong> la fonction de perte sur l'ensemble des donn√©es d'entra√Ænement. C'est un probl√®me d'<strong>optimisation</strong>. Le prochain slide explique comment y parvenir gr√¢ce √† la r√©tropropagation.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="dl-footer border-t py-8 text-center text-sm">
        <p>Deep Learning pour l'impatient ‚Äî Slide 4/8</p>
    </footer>

</body>
</html>
