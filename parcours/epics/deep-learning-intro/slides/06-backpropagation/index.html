<!DOCTYPE html>
<html lang="fr" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√©tropropagation - Deep Learning</title>

    <link rel="stylesheet" href="../../../../../lib/theme.css">
    <link rel="stylesheet" href="../../_shared/deep-learning.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="module">
        import { initSlide, initGlossary, sendTOC, setupScrollHandler } from '../../../../../parcours/_shared/slide-utils.js';
        initSlide();
        initGlossary();
        setupScrollHandler();
        sendTOC([
            { id: 'history', label: 'Histoire', icon: 'üìú' },
            { id: 'gradients', label: 'Calcul des Gradients', icon: 'üîó' },
            { id: 'update', label: 'Mise √† Jour', icon: 'üîß' },
            { id: 'adam', label: 'Adam', icon: 'üöÄ' },
            { id: 'pitfalls', label: 'Pi√®ges', icon: '‚ö†Ô∏è' },
        ]);
    </script>
</head>
<body class="antialiased selection:bg-blue-500 selection:text-white">

    <main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">

        <section id="backprop" class="mb-16">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">‚¨ÖÔ∏è</span>
                <h2 class="text-3xl font-bold dl-text-primary">R√©tropropagation</h2>
            </div>

            <div class="prose-content dl-text-secondary">

                <p class="text-lg mb-6 dl-text-primary font-medium">
                    La <dfn>r√©tropropagation</dfn> est l'algorithme qui a rendu le Deep Learning possible. Elle r√©pond √† deux questions : <em>"de combien chaque poids contribue-t-il √† l'erreur ?"</em> (calcul des gradients) et <em>"comment corriger ces poids ?"</em> (optimisation).
                </p>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                     PARTIE 1 : HISTOIRE
                     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <h3 id="history" class="text-xl font-bold dl-text-primary mt-10 mb-4 scroll-mt-24">Un peu d'histoire</h3>

                <p class="mb-4">
                    La r√©tropropagation n'est pas une invention soudaine, mais le fruit de d√©cennies de recherche. Son histoire est jalonn√©e de red√©couvertes et d'oublis.
                </p>

                <div class="space-y-3 my-6">
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">1970</span>
                        <h4 class="text-base font-semibold dl-text-primary">Seppo Linnainmaa</h4>
                        <p class="dl-text-muted mt-1 text-sm">Formalise le "mode inverse" de la diff√©rentiation automatique. Tous les frameworks modernes (TensorFlow, PyTorch) reposent encore sur son algorithme.</p>
                    </div>
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">1974</span>
                        <h4 class="text-base font-semibold dl-text-primary">Paul Werbos</h4>
                        <p class="dl-text-muted mt-1 text-sm">Propose d'appliquer la r√®gle de la cha√Æne aux r√©seaux de neurones dans sa th√®se √† Harvard. C'est l'hiver de l'IA ‚Äî personne n'√©coute.</p>
                    </div>
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">1986</span>
                        <h4 class="text-base font-semibold dl-text-primary">Rumelhart, Hinton & Williams</h4>
                        <p class="dl-text-muted mt-1 text-sm">Leur article dans <em>Nature</em> popularise enfin la technique et r√©sout le fameux probl√®me XOR.</p>
                    </div>
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">2012</span>
                        <h4 class="text-base font-semibold dl-text-primary">AlexNet</h4>
                        <p class="dl-text-muted mt-1 text-sm">Victoire √©crasante sur ImageNet. 8 couches, 60M param√®tres, GPU. Le Deep Learning moderne est n√©.</p>
                    </div>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                     PARTIE 2 : CALCUL DES GRADIENTS
                     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <h3 id="gradients" class="text-xl font-bold dl-text-primary mt-12 mb-4 scroll-mt-24">√âtape 1 : Calculer les Gradients</h3>

                <p class="mb-6">
                    On veut calculer \(\frac{\partial L}{\partial w}\) pour chaque poids : "si je bouge ce poids un peu, de combien l'erreur change-t-elle ?"
                </p>

                <div class="concept-box mb-6">
                    <h4 class="font-bold text-blue-400 mb-3">La R√®gle de la Cha√Æne</h4>
                    <p class="dl-text-secondary text-sm mb-4">
                        Si \(L\) d√©pend de \(a\), qui d√©pend de \(z\), qui d√©pend de \(w\), alors :
                    </p>
                    <div class="math-block text-center">
                        $$ \frac{\partial L}{\partial w} = \frac{\partial L}{\partial a} \cdot \frac{\partial a}{\partial z} \cdot \frac{\partial z}{\partial w} $$
                    </div>
                    <p class="dl-text-muted text-xs mt-3">
                        On d√©compose un calcul complexe en calculs simples, multipli√©s ensemble.
                    </p>
                </div>

                <div class="step-indicator">
                    <span class="step-number">1</span>
                    <span class="dl-text-primary font-semibold">Erreur de sortie</span>
                </div>
                <p class="mb-2 ml-10 text-sm">On commence par la fin :</p>
                <div class="math-block text-sm mb-4">
                    $$ \delta^{[L]} = -(y - \hat{y}) $$
                </div>

                <div class="step-indicator">
                    <span class="step-number">2</span>
                    <span class="dl-text-primary font-semibold">Propagation arri√®re</span>
                </div>
                <p class="mb-2 ml-10 text-sm">Pour chaque couche, on propage l'erreur en arri√®re :</p>
                <div class="math-block text-sm mb-4">
                    $$ \delta^{[l]} = \delta^{[l+1]} \cdot W^{[l+1]} \cdot \sigma'(z^{[l]}) $$
                </div>

                <!-- Visualisation tanh et sa d√©riv√©e -->
                <div class="my-6 p-4 dl-card rounded-xl border">
                    <h4 class="font-bold text-orange-400 mb-2 text-sm text-center">Le Probl√®me de la Saturation</h4>
                    <p class="text-sm dl-text-secondary mb-3">
                        Dans la formule, on <strong>multiplie par œÉ'(z)</strong> √† chaque couche. Probl√®me : quand un neurone est <em>satur√©</em> (z tr√®s grand ou tr√®s petit), sa d√©riv√©e œÉ'(z) ‚âà 0. Le gradient se retrouve multipli√© par ~0 et <strong>dispara√Æt</strong>.
                    </p>
                    <div class="flex flex-col items-center">
                        <canvas id="tanhDerivCanvas" width="450" height="180" class="rounded-lg" style="max-width: 450px;"></canvas>
                        <p class="text-xs dl-text-muted mt-2 italic">Survolez pour voir les valeurs. Notez que tanh'(z) ‚Üí 0 aux extr√©mit√©s.</p>
                        <div class="flex gap-6 mt-2">
                            <div class="flex items-center gap-2">
                                <span class="inline-block w-4 h-1 rounded" style="background: #22d3ee;"></span>
                                <span class="text-xs dl-text-secondary">tanh(z) ‚Äî activation</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="inline-block w-4 h-1 rounded" style="background: #f97316;"></span>
                                <span class="text-xs dl-text-secondary">tanh'(z) ‚Äî d√©riv√©e</span>
                            </div>
                        </div>
                    </div>
                    <div class="mt-3 p-2 bg-red-500/10 border border-red-500/30 rounded-lg">
                        <p class="text-xs dl-text-secondary">
                            <strong class="text-red-400">Vanishing Gradient :</strong> avec 10 couches et œÉ'(z) ‚âà 0.1 √† chaque couche, le gradient est multipli√© par 0.1<sup>10</sup> = <strong>0.0000000001</strong>. Les premi√®res couches ne re√ßoivent plus aucun signal d'apprentissage.
                        </p>
                    </div>
                </div>

                <script>
                (function() {
                    const canvas = document.getElementById('tanhDerivCanvas');
                    const ctx = canvas.getContext('2d');
                    const W = canvas.width, H = canvas.height;
                    const margin = { top: 15, right: 15, bottom: 25, left: 35 };
                    const plotW = W - margin.left - margin.right;
                    const plotH = H - margin.top - margin.bottom;

                    const xMin = -4, xMax = 4, yMin = -1.2, yMax = 1.2;
                    const toCanvasX = x => margin.left + (x - xMin) / (xMax - xMin) * plotW;
                    const toCanvasY = y => margin.top + (yMax - y) / (yMax - yMin) * plotH;
                    const fromCanvasX = cx => xMin + (cx - margin.left) / plotW * (xMax - xMin);

                    const tanh = z => Math.tanh(z);
                    const tanhDeriv = z => 1 - Math.pow(Math.tanh(z), 2);
                    let mouseX = null;

                    function draw() {
                        const isDark = document.documentElement.classList.contains('dark');
                        const bgColor = isDark ? '#1a1a2e' : '#f8fafc';
                        const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                        const axisColor = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                        const textColor = isDark ? '#94a3b8' : '#64748b';

                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, W, H);

                        ctx.strokeStyle = gridColor;
                        ctx.lineWidth = 1;
                        for (let x = -4; x <= 4; x += 2) {
                            ctx.beginPath(); ctx.moveTo(toCanvasX(x), margin.top); ctx.lineTo(toCanvasX(x), H - margin.bottom); ctx.stroke();
                        }
                        for (let y = -1; y <= 1; y += 0.5) {
                            ctx.beginPath(); ctx.moveTo(margin.left, toCanvasY(y)); ctx.lineTo(W - margin.right, toCanvasY(y)); ctx.stroke();
                        }

                        ctx.strokeStyle = axisColor; ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.moveTo(toCanvasX(0), margin.top); ctx.lineTo(toCanvasX(0), H - margin.bottom);
                        ctx.moveTo(margin.left, toCanvasY(0)); ctx.lineTo(W - margin.right, toCanvasY(0)); ctx.stroke();

                        ctx.fillStyle = textColor; ctx.font = '10px monospace'; ctx.textAlign = 'center';
                        ctx.fillText('-4', toCanvasX(-4), H - margin.bottom + 12);
                        ctx.fillText('0', toCanvasX(0), H - margin.bottom + 12);
                        ctx.fillText('4', toCanvasX(4), H - margin.bottom + 12);
                        ctx.textAlign = 'right';
                        ctx.fillText('1', margin.left - 4, toCanvasY(1) + 3);

                        ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let px = margin.left; px <= W - margin.right; px++) {
                            const x = fromCanvasX(px), y = tanh(x);
                            px === margin.left ? ctx.moveTo(px, toCanvasY(y)) : ctx.lineTo(px, toCanvasY(y));
                        }
                        ctx.stroke();

                        ctx.strokeStyle = '#f97316'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let px = margin.left; px <= W - margin.right; px++) {
                            const x = fromCanvasX(px), y = tanhDeriv(x);
                            px === margin.left ? ctx.moveTo(px, toCanvasY(y)) : ctx.lineTo(px, toCanvasY(y));
                        }
                        ctx.stroke();

                        if (mouseX !== null && mouseX >= margin.left && mouseX <= W - margin.right) {
                            const z = fromCanvasX(mouseX), yT = tanh(z), yD = tanhDeriv(z);
                            ctx.strokeStyle = axisColor; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
                            ctx.beginPath(); ctx.moveTo(mouseX, margin.top); ctx.lineTo(mouseX, H - margin.bottom); ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.fillStyle = '#22d3ee'; ctx.beginPath(); ctx.arc(mouseX, toCanvasY(yT), 4, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.arc(mouseX, toCanvasY(yD), 4, 0, Math.PI * 2); ctx.fill();
                            ctx.font = 'bold 10px monospace'; ctx.textAlign = 'left';
                            const infoX = mouseX > W * 0.6 ? mouseX - 90 : mouseX + 8;
                            ctx.fillStyle = textColor; ctx.fillText(`z=${z.toFixed(1)}`, infoX, margin.top + 12);
                            ctx.fillStyle = '#f97316'; ctx.fillText(`œÉ'=${yD.toFixed(2)}`, infoX, margin.top + 24);
                        }
                    }

                    canvas.addEventListener('mousemove', e => { mouseX = (e.clientX - canvas.getBoundingClientRect().left) * (W / canvas.getBoundingClientRect().width); draw(); });
                    canvas.addEventListener('mouseleave', () => { mouseX = null; draw(); });
                    new MutationObserver(draw).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
                    draw();
                })();
                </script>

                <div class="step-indicator">
                    <span class="step-number">3</span>
                    <span class="dl-text-primary font-semibold">Gradient de chaque poids</span>
                </div>
                <p class="mb-2 ml-10 text-sm">On obtient le gradient pour chaque poids :</p>
                <div class="math-block text-sm">
                    $$ \frac{\partial L}{\partial W^{[l]}} = \delta^{[l]} \cdot (a^{[l-1]})^T $$
                </div>

                <div class="analogy-box mt-6">
                    <div class="flex items-start gap-3">
                        <span class="text-xl">üí°</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-1">Le jeu du t√©l√©phone invers√©</h4>
                            <p class="dl-text-secondary text-sm">
                                Le dernier re√ßoit "tu t'es tromp√© de X", chuchote √† celui devant "c'est en partie ta faute". √Ä la fin, chacun conna√Æt <strong>sa part de responsabilit√©</strong> dans l'erreur.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                     PARTIE 3 : MISE √Ä JOUR DES POIDS
                     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <h3 id="update" class="text-xl font-bold dl-text-primary mt-12 mb-4 scroll-mt-24">√âtape 2 : Mettre √† Jour les Poids</h3>

                <p class="mb-4">
                    Maintenant qu'on a les gradients, on corrige les poids. La m√©thode de base est la <strong>descente de gradient</strong> :
                </p>

                <div class="math-block text-center mb-6">
                    $$ w_{t+1} = w_t - \eta \cdot \frac{\partial L}{\partial w} $$
                </div>

                <p class="mb-6 text-sm dl-text-muted">
                    O√π \(\eta\) est le <dfn data-term="learning rate">taux d'apprentissage</dfn> ‚Äî la taille du pas √† chaque it√©ration.
                </p>

                <!-- Visualisation descente de gradient -->
                <div class="my-6 p-4 dl-card rounded-xl border">
                    <h4 class="font-bold text-blue-400 mb-3 text-center">Descente de Gradient Interactive</h4>
                    <div class="flex flex-col items-center gap-3">
                        <canvas id="gradientCanvas" width="480" height="220" class="rounded-lg" style="max-width: 480px;"></canvas>
                        <div class="flex flex-wrap justify-center gap-3">
                            <div class="flex items-center gap-2">
                                <label class="text-sm dl-text-secondary">Œ∑ =</label>
                                <input type="range" id="learningRate" min="0.01" max="1.5" step="0.01" value="0.3" class="w-20">
                                <span id="lrValue" class="font-mono text-cyan-400 w-10 text-sm">0.30</span>
                            </div>
                            <button id="resetGradient" class="px-3 py-1 text-xs bg-blue-500/20 hover:bg-blue-500/30 border border-blue-500/50 rounded-lg">Reset</button>
                            <button id="stepGradient" class="px-3 py-1 text-xs bg-green-500/20 hover:bg-green-500/30 border border-green-500/50 rounded-lg">Step</button>
                            <button id="runGradient" class="px-3 py-1 text-xs bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/50 rounded-lg">‚ñ∂ Run</button>
                        </div>
                        <p class="text-xs dl-text-muted">Cliquez pour placer la bille. Testez diff√©rentes valeurs de Œ∑.</p>
                    </div>
                </div>

                <script>
                (function() {
                    const canvas = document.getElementById('gradientCanvas');
                    const ctx = canvas.getContext('2d');
                    const lrSlider = document.getElementById('learningRate');
                    const lrValue = document.getElementById('lrValue');
                    const W = canvas.width, H = canvas.height;
                    const margin = { top: 20, right: 20, bottom: 25, left: 40 };
                    const plotW = W - margin.left - margin.right;
                    const plotH = H - margin.top - margin.bottom;

                    const xMin = -3.5, xMax = 3.5, yMin = 0, yMax = 4;
                    const toCanvasX = x => margin.left + (x - xMin) / (xMax - xMin) * plotW;
                    const toCanvasY = y => margin.top + (yMax - y) / (yMax - yMin) * plotH;
                    const fromCanvasX = cx => xMin + (cx - margin.left) / plotW * (xMax - xMin);

                    const loss = w => Math.sin(1.5 * w) + 0.1 * w * w + 1.5;
                    const gradient = w => 1.5 * Math.cos(1.5 * w) + 0.2 * w;

                    let w = 3.0, history = [w], running = false, animId = null;
                    const runBtn = document.getElementById('runGradient');

                    function draw() {
                        const lr = parseFloat(lrSlider.value);
                        lrValue.textContent = lr.toFixed(2);

                        const isDark = document.documentElement.classList.contains('dark');
                        const bgColor = isDark ? '#1a1a2e' : '#f8fafc';
                        const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                        const axisColor = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                        const textColor = isDark ? '#94a3b8' : '#64748b';

                        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, W, H);

                        ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
                        for (let x = -3; x <= 3; x++) { ctx.beginPath(); ctx.moveTo(toCanvasX(x), margin.top); ctx.lineTo(toCanvasX(x), H - margin.bottom); ctx.stroke(); }
                        for (let y = 0; y <= 4; y++) { ctx.beginPath(); ctx.moveTo(margin.left, toCanvasY(y)); ctx.lineTo(W - margin.right, toCanvasY(y)); ctx.stroke(); }

                        ctx.strokeStyle = axisColor; ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.moveTo(toCanvasX(0), margin.top); ctx.lineTo(toCanvasX(0), H - margin.bottom);
                        ctx.moveTo(margin.left, toCanvasY(0)); ctx.lineTo(W - margin.right, toCanvasY(0)); ctx.stroke();

                        ctx.fillStyle = textColor; ctx.font = '10px monospace'; ctx.textAlign = 'center';
                        ctx.fillText('w', W - margin.right + 8, toCanvasY(0) + 3);
                        ctx.textAlign = 'right'; ctx.fillText('L(w)', margin.left - 4, margin.top + 8);

                        ctx.strokeStyle = '#f97316'; ctx.lineWidth = 2.5; ctx.beginPath();
                        for (let px = margin.left; px <= W - margin.right; px++) {
                            const x = fromCanvasX(px), y = loss(x);
                            px === margin.left ? ctx.moveTo(px, toCanvasY(Math.min(y, yMax))) : ctx.lineTo(px, toCanvasY(Math.min(y, yMax)));
                        }
                        ctx.stroke();

                        if (history.length > 1) {
                            ctx.strokeStyle = 'rgba(34, 211, 238, 0.4)'; ctx.lineWidth = 2; ctx.beginPath();
                            for (let i = 0; i < history.length; i++) {
                                const hw = history[i], px = toCanvasX(hw), py = toCanvasY(loss(hw));
                                i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                            for (let i = 0; i < history.length - 1; i++) {
                                ctx.fillStyle = 'rgba(34, 211, 238, 0.3)'; ctx.beginPath();
                                ctx.arc(toCanvasX(history[i]), toCanvasY(loss(history[i])), 3, 0, Math.PI * 2); ctx.fill();
                            }
                        }

                        const currentLoss = loss(w);
                        ctx.fillStyle = '#22d3ee'; ctx.beginPath(); ctx.arc(toCanvasX(w), toCanvasY(currentLoss), 9, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = '#0e7490'; ctx.lineWidth = 2; ctx.stroke();

                        const grad = gradient(w), arrowLen = Math.min(Math.abs(grad) * 18, 45), arrowDir = grad > 0 ? -1 : 1;
                        const arrowX = toCanvasX(w) + arrowDir * arrowLen, arrowY = toCanvasY(currentLoss);
                        ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.moveTo(toCanvasX(w), arrowY); ctx.lineTo(arrowX, arrowY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(arrowX, arrowY); ctx.lineTo(arrowX - arrowDir * 7, arrowY - 4); ctx.lineTo(arrowX - arrowDir * 7, arrowY + 4); ctx.closePath();
                        ctx.fillStyle = '#22c55e'; ctx.fill();

                        ctx.fillStyle = textColor; ctx.font = 'bold 10px monospace'; ctx.textAlign = 'left';
                        ctx.fillText(`w=${w.toFixed(2)}  L=${currentLoss.toFixed(2)}  step=${history.length - 1}`, margin.left + 5, margin.top + 12);

                        let lrStatus = '', lrColor = textColor;
                        if (lr > 0.8) { lrStatus = '‚ö†Ô∏è trop grand'; lrColor = '#ef4444'; }
                        else if (lr < 0.1) { lrStatus = 'üêå lent'; lrColor = '#eab308'; }
                        else { lrStatus = '‚úì'; lrColor = '#22c55e'; }
                        ctx.fillStyle = lrColor; ctx.textAlign = 'right'; ctx.fillText(lrStatus, W - margin.right - 5, margin.top + 12);
                    }

                    function step() {
                        const lr = parseFloat(lrSlider.value), grad = gradient(w);
                        w = Math.max(xMin + 0.1, Math.min(xMax - 0.1, w - lr * grad));
                        history.push(w); if (history.length > 100) history.shift(); draw();
                    }

                    function stop() {
                        running = false; if (animId) { clearTimeout(animId); animId = null; }
                        runBtn.textContent = '‚ñ∂ Run';
                        runBtn.classList.remove('bg-red-500/20', 'border-red-500/50');
                        runBtn.classList.add('bg-purple-500/20', 'border-purple-500/50');
                    }

                    function reset() { stop(); w = 3.0; history = [w]; draw(); }

                    function run() {
                        if (running) { stop(); return; }
                        running = true; runBtn.textContent = '‚èπ Stop';
                        runBtn.classList.remove('bg-purple-500/20', 'border-purple-500/50');
                        runBtn.classList.add('bg-red-500/20', 'border-red-500/50');
                        (function animate() { if (!running) return; step(); animId = setTimeout(animate, 80); })();
                    }

                    canvas.addEventListener('click', e => {
                        stop(); const rect = canvas.getBoundingClientRect();
                        w = Math.max(xMin + 0.1, Math.min(xMax - 0.1, fromCanvasX((e.clientX - rect.left) * (W / rect.width))));
                        history = [w]; draw();
                    });

                    lrSlider.addEventListener('input', draw);
                    document.getElementById('resetGradient').addEventListener('click', reset);
                    document.getElementById('stepGradient').addEventListener('click', step);
                    document.getElementById('runGradient').addEventListener('click', run);
                    new MutationObserver(draw).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
                    draw();
                })();
                </script>

                <div class="grid md:grid-cols-2 gap-3 my-6">
                    <div class="bg-red-500/10 border border-red-500/30 p-3 rounded-xl">
                        <h4 class="font-bold text-red-400 mb-1 text-sm">Œ∑ trop grand</h4>
                        <p class="text-xs dl-text-muted">On "saute" par-dessus le minimum, oscillations, divergence.</p>
                    </div>
                    <div class="bg-yellow-500/10 border border-yellow-500/30 p-3 rounded-xl">
                        <h4 class="font-bold text-yellow-500 mb-1 text-sm">Œ∑ trop petit</h4>
                        <p class="text-xs dl-text-muted">Convergence tr√®s lente, risque de rester dans un minimum local.</p>
                    </div>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                     PARTIE 4 : ADAM
                     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <h3 id="adam" class="text-xl font-bold dl-text-primary mt-12 mb-4 scroll-mt-24">L'Optimiseur Adam</h3>

                <p class="mb-4">
                    La descente de gradient "vanilla" a des limitations. <strong>Adam</strong> (2015) combine deux am√©liorations :
                </p>

                <div class="grid md:grid-cols-2 gap-4 my-6">
                    <div class="dl-card p-4 rounded-xl border">
                        <h4 class="font-bold text-purple-400 mb-2 text-sm">Momentum</h4>
                        <p class="text-xs dl-text-muted mb-2">
                            Moyenne mobile des gradients pass√©s ‚Üí "lisse" la trajectoire et acc√©l√®re.
                        </p>
                        <div class="math-block text-xs py-1">$$ m_t = \beta_1 m_{t-1} + (1-\beta_1) g_t $$</div>
                    </div>
                    <div class="dl-card p-4 rounded-xl border">
                        <h4 class="font-bold text-orange-400 mb-2 text-sm">Taux Adaptatif</h4>
                        <p class="text-xs dl-text-muted mb-2">
                            Chaque poids a son propre Œ∑ ajust√© selon la variance de ses gradients.
                        </p>
                        <div class="math-block text-xs py-1">$$ v_t = \beta_2 v_{t-1} + (1-\beta_2) g_t^2 $$</div>
                    </div>
                </div>

                <!-- Visualisation Adam vs GD -->
                <div class="my-6 p-4 dl-card rounded-xl border">
                    <h4 class="font-bold text-blue-400 mb-3 text-center text-sm">Adam vs Descente de Gradient</h4>
                    <div class="flex flex-col items-center gap-3">
                        <canvas id="adamCanvas" width="480" height="200" class="rounded-lg" style="max-width: 480px;"></canvas>
                        <div class="flex flex-wrap justify-center gap-3">
                            <div class="flex items-center gap-2">
                                <label class="text-sm dl-text-secondary">Œ∑ =</label>
                                <input type="range" id="adamLR" min="0.01" max="1.0" step="0.01" value="0.3" class="w-16">
                                <span id="adamLRValue" class="font-mono text-cyan-400 w-10 text-sm">0.30</span>
                            </div>
                            <button id="resetAdam" class="px-2 py-1 text-xs bg-blue-500/20 border border-blue-500/50 rounded-lg">Reset</button>
                            <button id="runAdam" class="px-2 py-1 text-xs bg-purple-500/20 border border-purple-500/50 rounded-lg">‚ñ∂ Run</button>
                        </div>
                        <div class="flex gap-4 text-xs">
                            <span class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-cyan-400"></span> GD</span>
                            <span class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-purple-500"></span> Adam</span>
                        </div>
                    </div>
                </div>

                <script>
                (function() {
                    const canvas = document.getElementById('adamCanvas');
                    const ctx = canvas.getContext('2d');
                    const lrSlider = document.getElementById('adamLR');
                    const lrValue = document.getElementById('adamLRValue');
                    const W = canvas.width, H = canvas.height;
                    const margin = { top: 15, right: 15, bottom: 20, left: 35 };
                    const plotW = W - margin.left - margin.right, plotH = H - margin.top - margin.bottom;

                    const xMin = -3.5, xMax = 3.5, yMin = 0, yMax = 4;
                    const toCanvasX = x => margin.left + (x - xMin) / (xMax - xMin) * plotW;
                    const toCanvasY = y => margin.top + (yMax - y) / (yMax - yMin) * plotH;
                    const fromCanvasX = cx => xMin + (cx - margin.left) / plotW * (xMax - xMin);

                    const loss = w => Math.sin(1.5 * w) + 0.1 * w * w + 1.5;
                    const gradient = w => 1.5 * Math.cos(1.5 * w) + 0.2 * w;

                    let wGD = 3.0, historyGD = [wGD], wAdam = 3.0, historyAdam = [wAdam];
                    let m = 0, v = 0, t = 0;
                    const beta1 = 0.9, beta2 = 0.999, epsilon = 1e-8;
                    let running = false, animId = null;
                    const runBtn = document.getElementById('runAdam');

                    function draw() {
                        const lr = parseFloat(lrSlider.value);
                        lrValue.textContent = lr.toFixed(2);

                        const isDark = document.documentElement.classList.contains('dark');
                        const bgColor = isDark ? '#1a1a2e' : '#f8fafc';
                        const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                        const axisColor = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                        const textColor = isDark ? '#94a3b8' : '#64748b';

                        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, W, H);

                        ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
                        for (let x = -3; x <= 3; x++) { ctx.beginPath(); ctx.moveTo(toCanvasX(x), margin.top); ctx.lineTo(toCanvasX(x), H - margin.bottom); ctx.stroke(); }

                        ctx.strokeStyle = '#f97316'; ctx.lineWidth = 2.5; ctx.beginPath();
                        for (let px = margin.left; px <= W - margin.right; px++) {
                            const x = fromCanvasX(px), y = loss(x);
                            px === margin.left ? ctx.moveTo(px, toCanvasY(Math.min(y, yMax))) : ctx.lineTo(px, toCanvasY(Math.min(y, yMax)));
                        }
                        ctx.stroke();

                        if (historyGD.length > 1) {
                            ctx.strokeStyle = 'rgba(34, 211, 238, 0.4)'; ctx.lineWidth = 2; ctx.beginPath();
                            historyGD.forEach((hw, i) => i === 0 ? ctx.moveTo(toCanvasX(hw), toCanvasY(loss(hw))) : ctx.lineTo(toCanvasX(hw), toCanvasY(loss(hw))));
                            ctx.stroke();
                        }
                        if (historyAdam.length > 1) {
                            ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)'; ctx.lineWidth = 2; ctx.beginPath();
                            historyAdam.forEach((hw, i) => i === 0 ? ctx.moveTo(toCanvasX(hw), toCanvasY(loss(hw))) : ctx.lineTo(toCanvasX(hw), toCanvasY(loss(hw))));
                            ctx.stroke();
                        }

                        ctx.fillStyle = '#22d3ee'; ctx.beginPath(); ctx.arc(toCanvasX(wGD), toCanvasY(loss(wGD)), 7, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = '#0e7490'; ctx.lineWidth = 1.5; ctx.stroke();
                        ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.arc(toCanvasX(wAdam), toCanvasY(loss(wAdam)), 7, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 1.5; ctx.stroke();

                        ctx.font = 'bold 10px monospace'; ctx.textAlign = 'left';
                        ctx.fillStyle = '#22d3ee'; ctx.fillText(`GD: L=${loss(wGD).toFixed(2)}`, margin.left + 5, margin.top + 12);
                        ctx.fillStyle = '#a855f7'; ctx.fillText(`Adam: L=${loss(wAdam).toFixed(2)}`, margin.left + 5, margin.top + 24);
                        ctx.fillStyle = textColor; ctx.fillText(`step=${historyGD.length - 1}`, margin.left + 5, margin.top + 36);
                    }

                    function step() {
                        const lr = parseFloat(lrSlider.value);
                        wGD = Math.max(xMin + 0.1, Math.min(xMax - 0.1, wGD - lr * gradient(wGD)));
                        historyGD.push(wGD);

                        t++;
                        const g = gradient(wAdam);
                        m = beta1 * m + (1 - beta1) * g;
                        v = beta2 * v + (1 - beta2) * g * g;
                        const mHat = m / (1 - Math.pow(beta1, t)), vHat = v / (1 - Math.pow(beta2, t));
                        wAdam = Math.max(xMin + 0.1, Math.min(xMax - 0.1, wAdam - lr * mHat / (Math.sqrt(vHat) + epsilon)));
                        historyAdam.push(wAdam);

                        if (historyGD.length > 100) historyGD.shift();
                        if (historyAdam.length > 100) historyAdam.shift();
                        draw();
                    }

                    function stop() {
                        running = false; if (animId) { clearTimeout(animId); animId = null; }
                        runBtn.textContent = '‚ñ∂ Run';
                        runBtn.classList.remove('bg-red-500/20', 'border-red-500/50');
                        runBtn.classList.add('bg-purple-500/20', 'border-purple-500/50');
                    }

                    function reset() { stop(); wGD = 3.0; wAdam = 3.0; historyGD = [wGD]; historyAdam = [wAdam]; m = 0; v = 0; t = 0; draw(); }

                    function run() {
                        if (running) { stop(); return; }
                        running = true; runBtn.textContent = '‚èπ';
                        runBtn.classList.remove('bg-purple-500/20', 'border-purple-500/50');
                        runBtn.classList.add('bg-red-500/20', 'border-red-500/50');
                        (function animate() { if (!running) return; step(); animId = setTimeout(animate, 80); })();
                    }

                    canvas.addEventListener('click', e => {
                        stop(); const rect = canvas.getBoundingClientRect();
                        const newW = Math.max(xMin + 0.1, Math.min(xMax - 0.1, fromCanvasX((e.clientX - rect.left) * (W / rect.width))));
                        wGD = newW; wAdam = newW; historyGD = [wGD]; historyAdam = [wAdam]; m = 0; v = 0; t = 0; draw();
                    });

                    lrSlider.addEventListener('input', draw);
                    document.getElementById('resetAdam').addEventListener('click', reset);
                    document.getElementById('runAdam').addEventListener('click', run);
                    new MutationObserver(draw).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
                    draw();
                })();
                </script>

                <div class="analogy-box mt-6">
                    <div class="flex items-start gap-3">
                        <span class="text-xl">‚öΩ</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-1">La balle qui roule</h4>
                            <p class="dl-text-secondary text-sm">
                                <strong>Momentum</strong> = inertie : elle acc√©l√®re si elle roule toujours dans la m√™me direction. <strong>Taux adaptatif</strong> = freinage automatique sur terrain chaotique, acc√©l√©ration sur lignes droites.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                     PARTIE 5 : PI√àGES
                     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                <h3 id="pitfalls" class="text-xl font-bold dl-text-primary mt-12 mb-4 scroll-mt-24">Pi√®ges Classiques</h3>

                <div class="grid md:grid-cols-2 gap-3">
                    <div class="card-hover dl-card p-4 rounded-xl border">
                        <div class="flex items-center gap-2 mb-2">
                            <div class="w-8 h-8 rounded-lg bg-red-500/20 flex items-center justify-center">üìâ</div>
                            <h4 class="text-sm font-bold dl-text-primary"><dfn data-term="vanishing gradient">Vanishing Gradient</dfn></h4>
                        </div>
                        <p class="text-xs dl-text-muted mb-2">
                            Gradients minuscules dans les r√©seaux profonds ‚Üí les premi√®res couches n'apprennent plus.
                        </p>
                        <div class="text-xs text-blue-400 font-mono">ReLU, BatchNorm, ResNets</div>
                    </div>

                    <div class="card-hover dl-card p-4 rounded-xl border">
                        <div class="flex items-center gap-2 mb-2">
                            <div class="w-8 h-8 rounded-lg bg-orange-500/20 flex items-center justify-center">üí•</div>
                            <h4 class="text-sm font-bold dl-text-primary"><dfn data-term="exploding gradient">Exploding Gradient</dfn></h4>
                        </div>
                        <p class="text-xs dl-text-muted mb-2">
                            Gradients √©normes ‚Üí poids explosent vers l'infini, loss = NaN.
                        </p>
                        <div class="text-xs text-orange-400 font-mono">Gradient Clipping, Init Xavier</div>
                    </div>

                    <div class="card-hover dl-card p-4 rounded-xl border">
                        <div class="flex items-center gap-2 mb-2">
                            <div class="w-8 h-8 rounded-lg bg-yellow-500/20 flex items-center justify-center">üìö</div>
                            <h4 class="text-sm font-bold dl-text-primary"><dfn>Overfitting</dfn></h4>
                        </div>
                        <p class="text-xs dl-text-muted mb-2">
                            Le r√©seau apprend par c≈ìur au lieu de g√©n√©raliser.
                        </p>
                        <div class="text-xs text-yellow-500 font-mono">Dropout, Early Stopping, L2</div>
                    </div>

                    <div class="card-hover dl-card p-4 rounded-xl border">
                        <div class="flex items-center gap-2 mb-2">
                            <div class="w-8 h-8 rounded-lg bg-purple-500/20 flex items-center justify-center">üï≥Ô∏è</div>
                            <h4 class="text-sm font-bold dl-text-primary">Minimums Locaux</h4>
                        </div>
                        <p class="text-xs dl-text-muted mb-2">
                            En haute dimension, moins probl√©matique que pr√©vu (souvent des points-selle).
                        </p>
                        <div class="text-xs text-purple-400 font-mono">Adam, Momentum</div>
                    </div>
                </div>

                <div class="concept-box mt-8">
                    <div class="flex items-start gap-3">
                        <span class="text-xl">üéØ</span>
                        <div>
                            <h4 class="font-bold text-blue-400 mb-1">R√©capitulatif</h4>
                            <p class="dl-text-secondary text-sm">
                                <strong>R√©tropropagation</strong> = calcul efficace des gradients via la r√®gle de la cha√Æne.<br>
                                <strong>Optimisation</strong> = utilisation de ces gradients pour corriger les poids.<br>
                                Ces deux √©tapes forment la boucle d'apprentissage de tout r√©seau de neurones.
                            </p>
                        </div>
                    </div>
                </div>

            </div>
        </section>

    </main>

    <footer class="dl-footer border-t py-8 text-center text-sm">
        <p>Deep Learning pour l'impatient ‚Äî Slide 6/8</p>
    </footer>

</body>
</html>
