<!DOCTYPE html>
<html lang="fr" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimisation - Deep Learning</title>

    <link rel="stylesheet" href="../../../../../lib/theme.css">
    <link rel="stylesheet" href="../../_shared/deep-learning.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="module">
        import { initSlide, sendTOC, setupScrollHandler } from '../../../../../parcours/_shared/slide-utils.js';
        initSlide();
        setupScrollHandler();
        sendTOC([
            { id: 'gradient', label: 'Descente de Gradient', icon: 'üìâ' },
            { id: 'adam', label: 'Optimiseur Adam', icon: 'üöÄ' },
        ]);
    </script>
</head>
<body class="antialiased selection:bg-blue-500 selection:text-white">

    <main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">

        <section id="optimizer" class="mb-16">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">üîß</span>
                <h2 class="text-3xl font-bold dl-text-primary">La Descente de Gradient & Adam</h2>
            </div>

            <div class="prose-content dl-text-secondary">

                <div id="gradient" class="scroll-mt-24">
                    <p class="mb-6">
                        Maintenant qu'on a les gradients, on peut mettre √† jour les poids. La m√©thode la plus simple est la <strong>Descente de Gradient</strong> (Gradient Descent) :
                    </p>

                    <div class="math-block text-center">
                        $$ w_{t+1} = w_t - \eta \cdot \frac{\partial L}{\partial w} $$
                    </div>

                    <p class="mb-6">
                        O√π \(\eta\) est le <strong>taux d'apprentissage</strong> (learning rate). C'est la taille du pas qu'on fait √† chaque it√©ration.
                    </p>

                    <!-- Visualisation interactive descente de gradient -->
                    <div class="my-6 p-4 dl-card rounded-xl border">
                        <h4 class="font-bold text-blue-400 mb-3 text-center">Descente de Gradient Interactive</h4>
                        <div class="flex flex-col items-center gap-4">
                            <canvas id="gradientCanvas" width="500" height="240" class="rounded-lg" style="max-width: 500px;"></canvas>
                            <div class="flex flex-wrap justify-center gap-4">
                                <div class="flex items-center gap-2">
                                    <label class="text-sm dl-text-secondary">Œ∑ =</label>
                                    <input type="range" id="learningRate" min="0.01" max="1.5" step="0.01" value="0.3" class="w-24">
                                    <span id="lrValue" class="font-mono text-cyan-400 w-12">0.30</span>
                                </div>
                                <button id="resetGradient" class="px-3 py-1 text-sm bg-blue-500/20 hover:bg-blue-500/30 border border-blue-500/50 rounded-lg transition">Reset</button>
                                <button id="stepGradient" class="px-3 py-1 text-sm bg-green-500/20 hover:bg-green-500/30 border border-green-500/50 rounded-lg transition">Step</button>
                                <button id="runGradient" class="px-3 py-1 text-sm bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/50 rounded-lg transition">‚ñ∂ Run</button>
                            </div>
                            <p class="text-xs dl-text-muted">L(w) = sin(1.5w) + 0.1w¬≤ + 1.5 ‚Äî avec minima locaux. Cliquez pour placer la bille.</p>
                        </div>
                    </div>

                    <script>
                    (function() {
                        const canvas = document.getElementById('gradientCanvas');
                        const ctx = canvas.getContext('2d');
                        const lrSlider = document.getElementById('learningRate');
                        const lrValue = document.getElementById('lrValue');
                        const W = canvas.width, H = canvas.height;
                        const margin = { top: 20, right: 20, bottom: 30, left: 40 };
                        const plotW = W - margin.left - margin.right;
                        const plotH = H - margin.top - margin.bottom;

                        const xMin = -3.5, xMax = 3.5;
                        const yMin = 0, yMax = 4;
                        const toCanvasX = x => margin.left + (x - xMin) / (xMax - xMin) * plotW;
                        const toCanvasY = y => margin.top + (yMax - y) / (yMax - yMin) * plotH;
                        const fromCanvasX = cx => xMin + (cx - margin.left) / plotW * (xMax - xMin);

                        // Fonction de perte avec minima locaux clairs
                        const loss = w => Math.sin(1.5 * w) + 0.1 * w * w + 1.5;
                        const gradient = w => 1.5 * Math.cos(1.5 * w) + 0.2 * w;

                        let w = 3.0;
                        let history = [w];
                        let running = false;
                        let animId = null;
                        const runBtn = document.getElementById('runGradient');

                        function draw() {
                            const lr = parseFloat(lrSlider.value);
                            lrValue.textContent = lr.toFixed(2);

                            const isDark = document.documentElement.classList.contains('dark');
                            const bgColor = isDark ? '#1a1a2e' : '#f8fafc';
                            const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                            const axisColor = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                            const textColor = isDark ? '#94a3b8' : '#64748b';

                            ctx.fillStyle = bgColor;
                            ctx.fillRect(0, 0, W, H);

                            // Grille
                            ctx.strokeStyle = gridColor;
                            ctx.lineWidth = 1;
                            for (let x = -3; x <= 3; x++) {
                                ctx.beginPath();
                                ctx.moveTo(toCanvasX(x), margin.top);
                                ctx.lineTo(toCanvasX(x), H - margin.bottom);
                                ctx.stroke();
                            }
                            for (let y = 0; y <= 4; y++) {
                                ctx.beginPath();
                                ctx.moveTo(margin.left, toCanvasY(y));
                                ctx.lineTo(W - margin.right, toCanvasY(y));
                                ctx.stroke();
                            }

                            // Axes
                            ctx.strokeStyle = axisColor;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(toCanvasX(0), margin.top);
                            ctx.lineTo(toCanvasX(0), H - margin.bottom);
                            ctx.moveTo(margin.left, toCanvasY(0));
                            ctx.lineTo(W - margin.right, toCanvasY(0));
                            ctx.stroke();

                            // Labels
                            ctx.fillStyle = textColor;
                            ctx.font = '11px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText('w', W - margin.right + 10, toCanvasY(0) + 4);
                            ctx.fillText('-3', toCanvasX(-3), H - margin.bottom + 15);
                            ctx.fillText('0', toCanvasX(0), H - margin.bottom + 15);
                            ctx.fillText('3', toCanvasX(3), H - margin.bottom + 15);
                            ctx.textAlign = 'right';
                            ctx.fillText('L(w)', margin.left - 5, margin.top + 10);
                            ctx.fillText('2', margin.left - 5, toCanvasY(2) + 4);

                            // Courbe de perte
                            ctx.strokeStyle = '#f97316';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            for (let px = margin.left; px <= W - margin.right; px++) {
                                const x = fromCanvasX(px);
                                const y = loss(x);
                                if (px === margin.left) ctx.moveTo(px, toCanvasY(Math.min(y, yMax)));
                                else ctx.lineTo(px, toCanvasY(Math.min(y, yMax)));
                            }
                            ctx.stroke();

                            // Historique des positions
                            if (history.length > 1) {
                                ctx.strokeStyle = 'rgba(34, 211, 238, 0.5)';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                for (let i = 0; i < history.length; i++) {
                                    const hw = history[i];
                                    const px = toCanvasX(hw);
                                    const py = toCanvasY(loss(hw));
                                    if (i === 0) ctx.moveTo(px, py);
                                    else ctx.lineTo(px, py);
                                }
                                ctx.stroke();

                                // Points
                                for (let i = 0; i < history.length - 1; i++) {
                                    const hw = history[i];
                                    ctx.fillStyle = 'rgba(34, 211, 238, 0.3)';
                                    ctx.beginPath();
                                    ctx.arc(toCanvasX(hw), toCanvasY(loss(hw)), 4, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                            // Position actuelle (bille)
                            const currentLoss = loss(w);
                            ctx.fillStyle = '#22d3ee';
                            ctx.beginPath();
                            ctx.arc(toCanvasX(w), toCanvasY(currentLoss), 10, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#0e7490';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            // Fl√®che du gradient
                            const grad = gradient(w);
                            const arrowLen = Math.min(Math.abs(grad) * 20, 50);
                            const arrowDir = grad > 0 ? -1 : 1;
                            const arrowX = toCanvasX(w) + arrowDir * arrowLen;
                            const arrowY = toCanvasY(currentLoss);

                            ctx.strokeStyle = '#22c55e';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(toCanvasX(w), arrowY);
                            ctx.lineTo(arrowX, arrowY);
                            ctx.stroke();

                            // Pointe de fl√®che
                            ctx.beginPath();
                            ctx.moveTo(arrowX, arrowY);
                            ctx.lineTo(arrowX - arrowDir * 8, arrowY - 5);
                            ctx.lineTo(arrowX - arrowDir * 8, arrowY + 5);
                            ctx.closePath();
                            ctx.fillStyle = '#22c55e';
                            ctx.fill();

                            // Infos
                            ctx.fillStyle = textColor;
                            ctx.font = 'bold 11px monospace';
                            ctx.textAlign = 'left';
                            ctx.fillText(`w = ${w.toFixed(3)}`, margin.left + 10, margin.top + 15);
                            ctx.fillText(`L = ${currentLoss.toFixed(3)}`, margin.left + 10, margin.top + 30);
                            ctx.fillStyle = '#22c55e';
                            ctx.fillText(`‚àáL = ${grad.toFixed(3)}`, margin.left + 10, margin.top + 45);
                            ctx.fillStyle = textColor;
                            ctx.fillText(`step = ${history.length - 1}`, margin.left + 10, margin.top + 60);

                            // Indicateur learning rate
                            let lrStatus = '';
                            let lrColor = textColor;
                            if (lr > 0.8) { lrStatus = '‚ö†Ô∏è trop grand!'; lrColor = '#ef4444'; }
                            else if (lr < 0.1) { lrStatus = 'üêå tr√®s lent'; lrColor = '#eab308'; }
                            else { lrStatus = '‚úì bon'; lrColor = '#22c55e'; }
                            ctx.fillStyle = lrColor;
                            ctx.textAlign = 'right';
                            ctx.fillText(lrStatus, W - margin.right - 10, margin.top + 15);
                        }

                        function step() {
                            const lr = parseFloat(lrSlider.value);
                            const grad = gradient(w);
                            w = w - lr * grad;
                            w = Math.max(xMin + 0.1, Math.min(xMax - 0.1, w)); // Clamp
                            history.push(w);
                            if (history.length > 100) history.shift();
                            draw();
                        }

                        function stop() {
                            running = false;
                            if (animId) {
                                clearTimeout(animId);
                                animId = null;
                            }
                            runBtn.textContent = '‚ñ∂ Run';
                            runBtn.classList.remove('bg-red-500/20', 'border-red-500/50');
                            runBtn.classList.add('bg-purple-500/20', 'border-purple-500/50');
                        }

                        function reset() {
                            stop();
                            w = 3.0;
                            history = [w];
                            draw();
                        }

                        function run() {
                            if (running) {
                                stop();
                                return;
                            }
                            running = true;
                            runBtn.textContent = '‚èπ Stop';
                            runBtn.classList.remove('bg-purple-500/20', 'border-purple-500/50');
                            runBtn.classList.add('bg-red-500/20', 'border-red-500/50');

                            function animate() {
                                if (!running) return;
                                step();
                                animId = setTimeout(animate, 100);
                            }
                            animate();
                        }

                        canvas.addEventListener('click', e => {
                            stop();
                            const rect = canvas.getBoundingClientRect();
                            const cx = (e.clientX - rect.left) * (W / rect.width);
                            w = fromCanvasX(cx);
                            w = Math.max(xMin + 0.1, Math.min(xMax - 0.1, w));
                            history = [w];
                            draw();
                        });

                        lrSlider.addEventListener('input', draw);
                        document.getElementById('resetGradient').addEventListener('click', reset);
                        document.getElementById('stepGradient').addEventListener('click', step);
                        document.getElementById('runGradient').addEventListener('click', run);
                        new MutationObserver(draw).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
                        draw();
                    })();
                    </script>

                    <div class="grid md:grid-cols-2 gap-4 my-8">
                        <div class="bg-red-500/10 border border-red-500/30 p-4 rounded-xl">
                            <h4 class="font-bold text-red-400 mb-2">Œ∑ trop grand</h4>
                            <p class="text-sm dl-text-muted">On "saute" par-dessus le minimum, oscillation, divergence possible.</p>
                        </div>
                        <div class="bg-yellow-500/10 border border-yellow-500/30 p-4 rounded-xl">
                            <h4 class="font-bold text-yellow-500 mb-2">Œ∑ trop petit</h4>
                            <p class="text-sm dl-text-muted">Convergence tr√®s lente, risque de rester coinc√© dans un minimum local.</p>
                        </div>
                    </div>
                </div>

                <h3 id="adam" class="text-xl font-bold dl-text-primary mt-10 mb-4 scroll-mt-24">L'Optimiseur Adam</h3>

                <p class="mb-6">
                    La descente de gradient "vanilla" a des limitations. L'<strong>optimiseur Adam</strong> (Adaptive Moment Estimation) combine deux am√©liorations :
                </p>

                <div class="grid md:grid-cols-2 gap-6 my-8">
                    <div class="dl-card p-5 rounded-xl border">
                        <h4 class="font-bold text-purple-400 mb-3">Momentum</h4>
                        <p class="text-sm dl-text-muted mb-3">
                            Au lieu d'utiliser uniquement le gradient actuel, on utilise une <strong>moyenne mobile</strong> des gradients pass√©s. Cela "lisse" la trajectoire et acc√©l√®re la convergence.
                        </p>
                        <div class="math-block text-xs py-2">
                            $$ m_t = \beta_1 \cdot m_{t-1} + (1-\beta_1) \cdot g_t $$
                        </div>
                    </div>
                    <div class="dl-card p-5 rounded-xl border">
                        <h4 class="font-bold text-orange-400 mb-3">Taux Adaptatif</h4>
                        <p class="text-sm dl-text-muted mb-3">
                            Chaque poids a son propre learning rate qui s'ajuste en fonction de la <strong>variance de ses gradients</strong>. Un poids avec des gradients stables avance plus vite.
                        </p>
                        <div class="math-block text-xs py-2">
                            $$ v_t = \beta_2 \cdot v_{t-1} + (1-\beta_2) \cdot g_t^2 $$
                        </div>
                    </div>
                </div>

                <!-- Visualisation interactive Adam -->
                <div class="my-6 p-4 dl-card rounded-xl border">
                    <h4 class="font-bold text-blue-400 mb-3 text-center">Adam vs Descente de Gradient</h4>
                    <div class="flex flex-col items-center gap-4">
                        <canvas id="adamCanvas" width="500" height="240" class="rounded-lg" style="max-width: 500px;"></canvas>
                        <div class="flex flex-wrap justify-center gap-4">
                            <div class="flex items-center gap-2">
                                <label class="text-sm dl-text-secondary">Œ∑ =</label>
                                <input type="range" id="adamLR" min="0.01" max="1.0" step="0.01" value="0.3" class="w-20">
                                <span id="adamLRValue" class="font-mono text-cyan-400 w-10">0.30</span>
                            </div>
                            <button id="resetAdam" class="px-3 py-1 text-sm bg-blue-500/20 hover:bg-blue-500/30 border border-blue-500/50 rounded-lg transition">Reset</button>
                            <button id="stepAdam" class="px-3 py-1 text-sm bg-green-500/20 hover:bg-green-500/30 border border-green-500/50 rounded-lg transition">Step</button>
                            <button id="runAdam" class="px-3 py-1 text-sm bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/50 rounded-lg transition">‚ñ∂ Run</button>
                        </div>
                        <div class="flex gap-6 text-xs">
                            <div class="flex items-center gap-2">
                                <span class="inline-block w-3 h-3 rounded-full" style="background: #22d3ee;"></span>
                                <span class="dl-text-secondary">Gradient Descent</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="inline-block w-3 h-3 rounded-full" style="background: #a855f7;"></span>
                                <span class="dl-text-secondary">Adam (Œ≤‚ÇÅ=0.9, Œ≤‚ÇÇ=0.999)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <script>
                (function() {
                    const canvas = document.getElementById('adamCanvas');
                    const ctx = canvas.getContext('2d');
                    const lrSlider = document.getElementById('adamLR');
                    const lrValue = document.getElementById('adamLRValue');
                    const W = canvas.width, H = canvas.height;
                    const margin = { top: 20, right: 20, bottom: 30, left: 40 };
                    const plotW = W - margin.left - margin.right;
                    const plotH = H - margin.top - margin.bottom;

                    const xMin = -3.5, xMax = 3.5;
                    const yMin = 0, yMax = 4;
                    const toCanvasX = x => margin.left + (x - xMin) / (xMax - xMin) * plotW;
                    const toCanvasY = y => margin.top + (yMax - y) / (yMax - yMin) * plotH;
                    const fromCanvasX = cx => xMin + (cx - margin.left) / plotW * (xMax - xMin);

                    // M√™me fonction de perte
                    const loss = w => Math.sin(1.5 * w) + 0.1 * w * w + 1.5;
                    const gradient = w => 1.5 * Math.cos(1.5 * w) + 0.2 * w;

                    // √âtat GD
                    let wGD = 3.0;
                    let historyGD = [wGD];

                    // √âtat Adam
                    let wAdam = 3.0;
                    let historyAdam = [wAdam];
                    let m = 0, v = 0, t = 0;
                    const beta1 = 0.9, beta2 = 0.999, epsilon = 1e-8;

                    let running = false;
                    let animId = null;
                    const runBtn = document.getElementById('runAdam');

                    function draw() {
                        const lr = parseFloat(lrSlider.value);
                        lrValue.textContent = lr.toFixed(2);

                        const isDark = document.documentElement.classList.contains('dark');
                        const bgColor = isDark ? '#1a1a2e' : '#f8fafc';
                        const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                        const axisColor = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
                        const textColor = isDark ? '#94a3b8' : '#64748b';

                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, W, H);

                        // Grille
                        ctx.strokeStyle = gridColor;
                        ctx.lineWidth = 1;
                        for (let x = -3; x <= 3; x++) {
                            ctx.beginPath();
                            ctx.moveTo(toCanvasX(x), margin.top);
                            ctx.lineTo(toCanvasX(x), H - margin.bottom);
                            ctx.stroke();
                        }
                        for (let y = 0; y <= 4; y++) {
                            ctx.beginPath();
                            ctx.moveTo(margin.left, toCanvasY(y));
                            ctx.lineTo(W - margin.right, toCanvasY(y));
                            ctx.stroke();
                        }

                        // Axes
                        ctx.strokeStyle = axisColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(toCanvasX(0), margin.top);
                        ctx.lineTo(toCanvasX(0), H - margin.bottom);
                        ctx.moveTo(margin.left, toCanvasY(0));
                        ctx.lineTo(W - margin.right, toCanvasY(0));
                        ctx.stroke();

                        // Courbe de perte
                        ctx.strokeStyle = '#f97316';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        for (let px = margin.left; px <= W - margin.right; px++) {
                            const x = fromCanvasX(px);
                            const y = loss(x);
                            if (px === margin.left) ctx.moveTo(px, toCanvasY(Math.min(y, yMax)));
                            else ctx.lineTo(px, toCanvasY(Math.min(y, yMax)));
                        }
                        ctx.stroke();

                        // Historique GD
                        if (historyGD.length > 1) {
                            ctx.strokeStyle = 'rgba(34, 211, 238, 0.4)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            for (let i = 0; i < historyGD.length; i++) {
                                const hw = historyGD[i];
                                const px = toCanvasX(hw);
                                const py = toCanvasY(loss(hw));
                                if (i === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                        }

                        // Historique Adam
                        if (historyAdam.length > 1) {
                            ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            for (let i = 0; i < historyAdam.length; i++) {
                                const hw = historyAdam[i];
                                const px = toCanvasX(hw);
                                const py = toCanvasY(loss(hw));
                                if (i === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.stroke();
                        }

                        // Bille GD
                        ctx.fillStyle = '#22d3ee';
                        ctx.beginPath();
                        ctx.arc(toCanvasX(wGD), toCanvasY(loss(wGD)), 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#0e7490';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Bille Adam
                        ctx.fillStyle = '#a855f7';
                        ctx.beginPath();
                        ctx.arc(toCanvasX(wAdam), toCanvasY(loss(wAdam)), 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#7c3aed';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Infos
                        ctx.font = 'bold 11px monospace';
                        ctx.textAlign = 'left';
                        ctx.fillStyle = '#22d3ee';
                        ctx.fillText(`GD: w=${wGD.toFixed(2)}, L=${loss(wGD).toFixed(3)}`, margin.left + 10, margin.top + 15);
                        ctx.fillStyle = '#a855f7';
                        ctx.fillText(`Adam: w=${wAdam.toFixed(2)}, L=${loss(wAdam).toFixed(3)}`, margin.left + 10, margin.top + 30);
                        ctx.fillStyle = textColor;
                        ctx.fillText(`step = ${historyGD.length - 1}`, margin.left + 10, margin.top + 45);
                    }

                    function step() {
                        const lr = parseFloat(lrSlider.value);

                        // GD step
                        const gradGD = gradient(wGD);
                        wGD = wGD - lr * gradGD;
                        wGD = Math.max(xMin + 0.1, Math.min(xMax - 0.1, wGD));
                        historyGD.push(wGD);

                        // Adam step
                        t++;
                        const g = gradient(wAdam);
                        m = beta1 * m + (1 - beta1) * g;
                        v = beta2 * v + (1 - beta2) * g * g;
                        const mHat = m / (1 - Math.pow(beta1, t));
                        const vHat = v / (1 - Math.pow(beta2, t));
                        wAdam = wAdam - lr * mHat / (Math.sqrt(vHat) + epsilon);
                        wAdam = Math.max(xMin + 0.1, Math.min(xMax - 0.1, wAdam));
                        historyAdam.push(wAdam);

                        if (historyGD.length > 100) historyGD.shift();
                        if (historyAdam.length > 100) historyAdam.shift();
                        draw();
                    }

                    function stop() {
                        running = false;
                        if (animId) {
                            clearTimeout(animId);
                            animId = null;
                        }
                        runBtn.textContent = '‚ñ∂ Run';
                        runBtn.classList.remove('bg-red-500/20', 'border-red-500/50');
                        runBtn.classList.add('bg-purple-500/20', 'border-purple-500/50');
                    }

                    function reset() {
                        stop();
                        wGD = 3.0;
                        wAdam = 3.0;
                        historyGD = [wGD];
                        historyAdam = [wAdam];
                        m = 0; v = 0; t = 0;
                        draw();
                    }

                    function run() {
                        if (running) {
                            stop();
                            return;
                        }
                        running = true;
                        runBtn.textContent = '‚èπ Stop';
                        runBtn.classList.remove('bg-purple-500/20', 'border-purple-500/50');
                        runBtn.classList.add('bg-red-500/20', 'border-red-500/50');

                        function animate() {
                            if (!running) return;
                            step();
                            animId = setTimeout(animate, 100);
                        }
                        animate();
                    }

                    canvas.addEventListener('click', e => {
                        stop();
                        const rect = canvas.getBoundingClientRect();
                        const cx = (e.clientX - rect.left) * (W / rect.width);
                        const newW = fromCanvasX(cx);
                        wGD = Math.max(xMin + 0.1, Math.min(xMax - 0.1, newW));
                        wAdam = wGD;
                        historyGD = [wGD];
                        historyAdam = [wAdam];
                        m = 0; v = 0; t = 0;
                        draw();
                    });

                    lrSlider.addEventListener('input', draw);
                    document.getElementById('resetAdam').addEventListener('click', reset);
                    document.getElementById('stepAdam').addEventListener('click', step);
                    document.getElementById('runAdam').addEventListener('click', run);
                    new MutationObserver(draw).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
                    draw();
                })();
                </script>

                <div class="analogy-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">‚öΩ</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-2">Analogie : La balle qui roule</h4>
                            <p class="dl-text-secondary text-sm">
                                Imaginez une balle qui roule dans une vall√©e. Le <strong>momentum</strong>, c'est son inertie : si elle roule toujours dans la m√™me direction, elle acc√©l√®re. Le <strong>taux adaptatif</strong>, c'est comme si la balle freinait automatiquement quand le terrain devient chaotique, mais acc√©l√©rait sur les lignes droites.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="concept-box mt-8">
                    <h4 class="font-bold text-blue-400 mb-3">Param√®tres Adam par d√©faut</h4>
                    <div class="grid grid-cols-3 gap-4 text-sm">
                        <div>
                            <span class="font-mono text-cyan-400">Œ≤‚ÇÅ = 0.9</span>
                            <p class="dl-text-muted text-xs mt-1">D√©croissance du momentum</p>
                        </div>
                        <div>
                            <span class="font-mono text-cyan-400">Œ≤‚ÇÇ = 0.999</span>
                            <p class="dl-text-muted text-xs mt-1">D√©croissance de la variance</p>
                        </div>
                        <div>
                            <span class="font-mono text-cyan-400">Œµ = 10‚Åª‚Å∏</span>
                            <p class="dl-text-muted text-xs mt-1">Stabilit√© num√©rique</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="dl-footer border-t py-8 text-center text-sm">
        <p>Deep Learning pour l'impatient ‚Äî Slide 6/8</p>
    </footer>

</body>
</html>
