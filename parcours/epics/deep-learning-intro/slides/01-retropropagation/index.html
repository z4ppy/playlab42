<!DOCTYPE html>
<html lang="fr" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction au Deep Learning - La R√©tropropagation</title>

    <!-- Th√®me Playlab42 -->
    <link rel="stylesheet" href="../../../../../lib/theme.css">
    <script type="module">
        import { initTheme } from '../../../../../lib/theme.js';
        initTheme();
    </script>

    <!-- D√©pendances pour le contenu interactif -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* Variables du th√®me adapt√©es */
        :root {
            --dl-bg-primary: #0a0f1a;
            --dl-bg-secondary: #111827;
            --dl-bg-tertiary: #1f2937;
            --dl-bg-card: #1e293b;
            --dl-accent-blue: #3b82f6;
            --dl-accent-cyan: #06b6d4;
            --dl-accent-purple: #8b5cf6;
            --dl-accent-green: #10b981;
            --dl-accent-yellow: #f59e0b;
            --dl-accent-red: #ef4444;
            --dl-accent-orange: #f97316;
            --dl-text-primary: #f1f5f9;
            --dl-text-secondary: #cbd5e1;
            --dl-text-muted: #94a3b8;
            --dl-border-color: #374151;
            --dl-nav-bg: rgba(15, 23, 42, 0.95);
            --dl-grid-color: #1e293b;
        }

        /* Support du th√®me light */
        [data-theme="light"] {
            --dl-bg-primary: #f8fafc;
            --dl-bg-secondary: #e2e8f0;
            --dl-bg-tertiary: #cbd5e1;
            --dl-bg-card: #ffffff;
            --dl-text-primary: #0f172a;
            --dl-text-secondary: #334155;
            --dl-text-muted: #64748b;
            --dl-border-color: #94a3b8;
            --dl-nav-bg: rgba(255, 255, 255, 0.95);
            --dl-grid-color: #e2e8f0;
        }

        @media (prefers-color-scheme: light) {
            :root:not([data-theme]) {
                --dl-bg-primary: #f8fafc;
                --dl-bg-secondary: #e2e8f0;
                --dl-bg-tertiary: #cbd5e1;
                --dl-bg-card: #ffffff;
                --dl-text-primary: #0f172a;
                --dl-text-secondary: #334155;
                --dl-text-muted: #64748b;
                --dl-border-color: #94a3b8;
                --dl-nav-bg: rgba(255, 255, 255, 0.95);
                --dl-grid-color: #e2e8f0;
            }
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--dl-bg-primary);
            color: var(--dl-text-primary);
            background-image:
                radial-gradient(ellipse at 20% 0%, rgba(59, 130, 246, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(139, 92, 246, 0.06) 0%, transparent 50%);
        }

        .font-mono { font-family: 'Monaco', 'Menlo', 'Consolas', monospace; }

        .prose-content {
            font-size: 1.05rem;
            line-height: 1.85;
        }

        .math-block {
            overflow-x: auto;
            padding: 1.25rem;
            background: linear-gradient(135deg, var(--dl-bg-secondary) 0%, var(--dl-bg-tertiary) 100%);
            border-radius: 0.75rem;
            margin: 1.5rem 0;
            border-left: 4px solid var(--dl-accent-blue);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .concept-box {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .analogy-box {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .warning-box {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .history-card {
            border-left: 2px solid var(--dl-border-color);
            padding-left: 1.5rem;
            position: relative;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
        }
        .history-card:hover { border-left-color: var(--dl-accent-blue); }
        .history-card::before {
            content: ''; position: absolute; left: -6px; top: 0;
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--dl-accent-blue); box-shadow: 0 0 10px var(--dl-accent-blue);
        }

        canvas { image-rendering: pixelated; }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--dl-bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--dl-border-color); border-radius: 4px; }

        .toggle-switch {
            position: relative; width: 40px; height: 20px;
            background: var(--dl-bg-tertiary); border-radius: 20px;
            cursor: pointer; transition: background 0.3s;
            border: 1px solid var(--dl-border-color);
        }
        .toggle-switch.active { background: var(--dl-accent-blue); border-color: var(--dl-accent-blue); }
        .toggle-switch::after {
            content: ''; position: absolute; width: 16px; height: 16px;
            background: white; border-radius: 50%; top: 1px; left: 2px;
            transition: transform 0.3s;
        }
        .toggle-switch.active::after { transform: translateX(18px); }

        .card-hover { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .card-hover:hover { transform: translateY(-2px); box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4); }

        .toast {
            position: fixed; bottom: 20px; right: 20px; z-index: 100;
            transform: translateY(100px); opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .toast.show { transform: translateY(0); opacity: 1; }

        .step-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .step-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--dl-accent-blue);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
        }

        /* === Classes utilitaires pour le th√®me === */
        /* Textes */
        .dl-text-primary { color: var(--dl-text-primary) !important; }
        .dl-text-secondary { color: var(--dl-text-secondary) !important; }
        .dl-text-muted { color: var(--dl-text-muted) !important; }

        /* Fonds */
        .dl-bg-primary { background-color: var(--dl-bg-primary) !important; }
        .dl-bg-secondary { background-color: var(--dl-bg-secondary) !important; }
        .dl-bg-tertiary { background-color: var(--dl-bg-tertiary) !important; }
        .dl-bg-card { background-color: var(--dl-bg-card) !important; }

        /* Bordures */
        .dl-border { border-color: var(--dl-border-color) !important; }

        /* Navigation */
        nav.dl-nav {
            background: var(--dl-nav-bg) !important;
            border-color: var(--dl-border-color) !important;
        }
        nav.dl-nav a { color: var(--dl-text-muted) !important; }
        nav.dl-nav a:hover { color: var(--dl-text-primary) !important; }
        nav.dl-nav a.active { color: var(--dl-accent-blue) !important; }
        nav.dl-nav .nav-title { color: var(--dl-text-primary) !important; }
        nav.dl-nav .nav-accent { color: var(--dl-accent-blue) !important; }

        /* Header hero */
        .hero-section {
            border-color: var(--dl-border-color) !important;
        }
        .hero-section .hero-grid {
            background-image: linear-gradient(to right, var(--dl-grid-color) 1px, transparent 1px),
                              linear-gradient(to bottom, var(--dl-grid-color) 1px, transparent 1px) !important;
        }

        /* Cards et boxes */
        .dl-card {
            background-color: var(--dl-bg-card) !important;
            border-color: var(--dl-border-color) !important;
        }
        .dl-card h3, .dl-card h4 { color: var(--dl-text-primary) !important; }
        .dl-card p { color: var(--dl-text-muted) !important; }

        /* Badges */
        .dl-badge {
            background-color: var(--dl-bg-secondary) !important;
            color: var(--dl-text-secondary) !important;
        }

        /* Lab sidebar */
        .lab-sidebar {
            background: var(--dl-bg-secondary) !important;
            border-color: var(--dl-border-color) !important;
        }
        .lab-panel {
            background: var(--dl-bg-tertiary) !important;
            border-color: var(--dl-border-color) !important;
        }
        .lab-metric {
            background: var(--dl-bg-primary) !important;
            border-color: var(--dl-border-color) !important;
        }

        /* Footer */
        footer.dl-footer {
            background: var(--dl-bg-secondary) !important;
            border-color: var(--dl-border-color) !important;
            color: var(--dl-text-muted) !important;
        }

        /* Inputs et selects */
        .dl-select {
            background: var(--dl-bg-tertiary) !important;
            border-color: var(--dl-border-color) !important;
            color: var(--dl-text-primary) !important;
        }
        .dl-input {
            background: var(--dl-bg-tertiary) !important;
        }

        /* Overlay rapide */
        .lab-overlay {
            background: rgba(0, 0, 0, 0.7) !important;
        }
        [data-theme="light"] .lab-overlay {
            background: rgba(255, 255, 255, 0.8) !important;
        }
        @media (prefers-color-scheme: light) {
            :root:not([data-theme]) .lab-overlay {
                background: rgba(255, 255, 255, 0.8) !important;
            }
        }

        /* Visualisation r√©seau */
        .lab-vis-area {
            background: var(--dl-bg-primary) !important;
        }
    </style>
</head>
<body class="antialiased selection:bg-blue-500 selection:text-white">

    <!-- Navigation -->
    <nav class="dl-nav sticky top-0 z-50 backdrop-blur-md border-b">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center">
                        <span class="text-xl">üß†</span>
                    </div>
                    <span class="nav-title font-bold text-xl">Deep Learning <span class="nav-accent">Introduction</span></span>
                </div>
                <div class="hidden md:flex space-x-6 text-sm font-medium">
                    <a href="#intro" class="transition-colors">Introduction</a>
                    <a href="#neuron" class="transition-colors">Le Neurone</a>
                    <a href="#forward" class="transition-colors">Forward</a>
                    <a href="#backprop" class="transition-colors">Backprop</a>
                    <a href="#optimizer" class="transition-colors">Optimiseur</a>
                    <a href="#simulation" class="active transition-colors font-semibold">Lab</a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <header class="hero-section relative py-20 overflow-hidden border-b">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 relative z-10 text-center">
            <div class="inline-block mb-6 px-4 py-1.5 rounded-full bg-purple-500/10 border border-purple-500/20 text-purple-400 text-sm font-medium">
                Cours Interactif Complet
            </div>
            <h1 class="text-4xl md:text-5xl lg:text-6xl font-extrabold dl-text-primary tracking-tight mb-6">
                Comment les r√©seaux de neurones <span class="bg-gradient-to-r from-blue-400 via-cyan-400 to-purple-500 bg-clip-text text-transparent">apprennent</span>
            </h1>
            <p class="max-w-2xl mx-auto text-lg dl-text-muted mb-8 leading-relaxed">
                Un voyage p√©dagogique de z√©ro √† expert, avec des analogies, des math√©matiques progressives, et un laboratoire interactif pour exp√©rimenter en temps r√©el.
            </p>
            <div class="flex flex-wrap justify-center gap-4 text-sm">
                <span class="dl-badge px-3 py-1 rounded-full">~30 min de lecture</span>
                <span class="dl-badge px-3 py-1 rounded-full">Niveau : D√©butant ‚Üí Interm√©diaire</span>
                <span class="dl-badge px-3 py-1 rounded-full">Lab interactif inclus</span>
            </div>
        </div>
        <div class="hero-grid absolute inset-0 bg-[size:4rem_4rem] [mask-image:radial-gradient(ellipse_60%_50%_at_50%_0%,#000_70%,transparent_100%)] opacity-30 pointer-events-none"></div>
    </header>

    <main class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">

        <!-- CHAPITRE 1: INTRODUCTION -->
        <section id="intro" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">üéØ</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 1 : L'Objectif</h2>
            </div>

            <div class="prose-content dl-text-secondary">
                <p class="mb-6">
                    Imaginez que vous devez apprendre √† un enfant √† reconna√Ætre des chats dans des photos. Vous ne lui donnez pas une liste de r√®gles ("un chat a des oreilles pointues, des moustaches..."). √Ä la place, vous lui montrez des milliers de photos en disant "chat" ou "pas chat". Petit √† petit, il <em>apprend</em> √† reconna√Ætre les patterns.
                </p>

                <div class="analogy-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">üß†</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-2">Analogie : L'√©l√®ve et le professeur</h4>
                            <p class="dl-text-secondary text-sm">
                                Un r√©seau de neurones est comme un √©l√®ve qui fait un exercice, v√©rifie sa r√©ponse, puis <strong>corrige ses erreurs</strong>. La r√©tropropagation est le m√©canisme qui lui permet de savoir <em>comment</em> corriger chaque partie de son raisonnement.
                            </p>
                        </div>
                    </div>
                </div>

                <p class="mb-6">
                    Le processus d'apprentissage d'un r√©seau de neurones se r√©sume en <strong>3 √©tapes</strong> r√©p√©t√©es des milliers de fois :
                </p>

                <div class="grid md:grid-cols-3 gap-4 my-8">
                    <div class="dl-card p-4 rounded-xl border text-center">
                        <div class="text-3xl mb-2">‚û°Ô∏è</div>
                        <h4 class="font-bold text-blue-400 mb-1">1. Forward Pass</h4>
                        <p class="text-xs dl-text-muted">Calculer une pr√©diction √† partir de l'entr√©e</p>
                    </div>
                    <div class="dl-card p-4 rounded-xl border text-center">
                        <div class="text-3xl mb-2">üìè</div>
                        <h4 class="font-bold text-yellow-500 mb-1">2. Mesurer l'Erreur</h4>
                        <p class="text-xs dl-text-muted">Comparer la pr√©diction √† la vraie r√©ponse</p>
                    </div>
                    <div class="dl-card p-4 rounded-xl border text-center">
                        <div class="text-3xl mb-2">‚¨ÖÔ∏è</div>
                        <h4 class="font-bold text-red-400 mb-1">3. Backprop</h4>
                        <p class="text-xs dl-text-muted">Propager l'erreur pour corriger les poids</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHAPITRE 2: LE NEURONE -->
        <section id="neuron" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">‚ö°</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 2 : Anatomie d'un Neurone</h2>
            </div>

            <div class="prose-content dl-text-secondary">
                <p class="mb-6">
                    Un neurone artificiel est une unit√© de calcul tr√®s simple. Il re√ßoit des nombres en entr√©e, les combine, et produit un nombre en sortie. Voici comment :
                </p>

                <div class="step-indicator">
                    <span class="step-number">1</span>
                    <span class="dl-text-primary font-semibold">Somme pond√©r√©e</span>
                </div>
                <p class="mb-4 ml-10">
                    Chaque entr√©e \(x_i\) est multipli√©e par un <strong>poids</strong> \(w_i\) (son "importance"), puis on additionne le tout avec un <strong>biais</strong> \(b\) :
                </p>
                <div class="math-block text-center">
                    $$ z = w_1 x_1 + w_2 x_2 + ... + w_n x_n + b = \sum_{i=1}^{n} w_i x_i + b $$
                </div>

                <div class="step-indicator">
                    <span class="step-number">2</span>
                    <span class="dl-text-primary font-semibold">Fonction d'activation</span>
                </div>
                <p class="mb-4 ml-10">
                    Cette somme passe dans une <strong>fonction d'activation</strong> qui introduit de la non-lin√©arit√© (sinon, empiler des couches ne servirait √† rien !) :
                </p>
                <div class="math-block text-center">
                    $$ a = \sigma(z) $$
                </div>

                <div class="concept-box">
                    <h4 class="font-bold text-blue-400 mb-3">Fonctions d'Activation Courantes</h4>
                    <div class="grid md:grid-cols-3 gap-4 text-sm">
                        <div>
                            <span class="font-mono text-cyan-400">tanh(z)</span>
                            <p class="dl-text-muted text-xs mt-1">Sortie entre -1 et 1. Utilis√©e dans notre simulation.</p>
                        </div>
                        <div>
                            <span class="font-mono text-cyan-400">sigmoid(z)</span>
                            <p class="dl-text-muted text-xs mt-1">Sortie entre 0 et 1. Id√©ale pour les probabilit√©s.</p>
                        </div>
                        <div>
                            <span class="font-mono text-cyan-400">ReLU(z)</span>
                            <p class="dl-text-muted text-xs mt-1">max(0, z). La plus populaire aujourd'hui.</p>
                        </div>
                    </div>
                </div>

                <div class="analogy-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">üö∞</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-2">Analogie : Le robinet et les tuyaux</h4>
                            <p class="dl-text-secondary text-sm">
                                Imaginez de l'eau qui coule dans des tuyaux. Les <strong>poids</strong> sont comme des vannes qui contr√¥lent le d√©bit. Les <strong>biais</strong> ajoutent ou retirent un peu d'eau. La <strong>fonction d'activation</strong> est un filtre qui d√©cide si l'eau passe ou non (et en quelle quantit√©).
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHAPITRE 3: FORWARD PROPAGATION -->
        <section id="forward" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">‚û°Ô∏è</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 3 : La Propagation Avant</h2>
            </div>

            <div class="prose-content dl-text-secondary">
                <p class="mb-6">
                    La <strong>propagation avant</strong> (forward propagation) est simplement le calcul de la sortie du r√©seau √† partir d'une entr√©e. L'information "coule" de gauche √† droite, couche par couche.
                </p>

                <p class="mb-6">
                    Pour chaque couche \(l\), on calcule :
                </p>

                <div class="math-block">
                    <p class="text-sm dl-text-muted mb-2">1. La somme pond√©r√©e :</p>
                    $$ z^{[l]} = W^{[l]} \cdot a^{[l-1]} + b^{[l]} $$
                    <p class="text-sm dl-text-muted mb-2 mt-4">2. L'activation :</p>
                    $$ a^{[l]} = \sigma(z^{[l]}) $$
                </div>

                <p class="mb-6">
                    O√π \(a^{[0]} = x\) (l'entr√©e). On r√©p√®te ce processus jusqu'√† la derni√®re couche pour obtenir la pr√©diction \(\hat{y} = a^{[L]}\).
                </p>

                <div class="analogy-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">üè≠</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-2">Analogie : La cha√Æne de production</h4>
                            <p class="dl-text-secondary text-sm">
                                Imaginez une usine avec plusieurs stations. La mati√®re premi√®re (entr√©e) passe de station en station. Chaque station la transforme un peu (poids + activation). √Ä la fin, vous obtenez le produit fini (pr√©diction). Si le produit est d√©fectueux, vous devez remonter la cha√Æne pour trouver <em>quelle</em> station a fait une erreur.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHAPITRE 4: LA FONCTION DE PERTE -->
        <section id="loss" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">üìè</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 4 : Mesurer l'Erreur</h2>
            </div>

            <div class="prose-content dl-text-secondary">
                <p class="mb-6">
                    Une fois qu'on a une pr√©diction \(\hat{y}\), il faut mesurer <strong>√† quel point elle est fausse</strong>. C'est le r√¥le de la <strong>fonction de perte</strong> (loss function).
                </p>

                <p class="mb-4">
                    La plus simple est l'<strong>Erreur Quadratique Moyenne</strong> (MSE) :
                </p>

                <div class="math-block text-center">
                    $$ L = \frac{1}{2}(y - \hat{y})^2 $$
                </div>

                <p class="mb-6">
                    Le facteur \(\frac{1}{2}\) est une convention pour simplifier les d√©riv√©es. Plus cette valeur est grande, plus le r√©seau se trompe.
                </p>

                <div class="concept-box">
                    <h4 class="font-bold text-blue-400 mb-3">L'Objectif de l'Entra√Ænement</h4>
                    <p class="dl-text-secondary text-sm">
                        Trouver les valeurs de poids \(W\) et biais \(b\) qui <strong>minimisent</strong> la fonction de perte sur l'ensemble des donn√©es d'entra√Ænement. C'est un probl√®me d'<strong>optimisation</strong>.
                    </p>
                </div>

                <div class="analogy-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">‚õ∞Ô∏è</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-2">Analogie : La montagne dans le brouillard</h4>
                            <p class="dl-text-secondary text-sm">
                                Imaginez que vous √™tes sur une montagne, les yeux band√©s, et vous voulez descendre au point le plus bas (le minimum de la perte). Vous ne pouvez que <strong>t√¢ter le sol autour de vous</strong> pour sentir la pente. √Ä chaque pas, vous allez dans la direction qui descend le plus. C'est la <strong>descente de gradient</strong>.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHAPITRE 5: BACKPROPAGATION -->
        <section id="backprop" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">‚¨ÖÔ∏è</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 5 : La R√©tropropagation</h2>
            </div>

            <div class="prose-content dl-text-secondary">
                <p class="mb-6">
                    Maintenant, la question cl√© : <strong>comment ajuster chaque poids pour r√©duire l'erreur ?</strong>
                </p>

                <p class="mb-6">
                    On doit calculer la <strong>d√©riv√©e partielle</strong> de la perte par rapport √† chaque poids : \(\frac{\partial L}{\partial w}\). Cette valeur nous dit : "si je bouge ce poids un tout petit peu, de combien l'erreur va-t-elle changer ?"
                </p>

                <div class="concept-box">
                    <h4 class="font-bold text-blue-400 mb-3">La R√®gle de la Cha√Æne (Chain Rule)</h4>
                    <p class="dl-text-secondary text-sm mb-4">
                        C'est l'outil math√©matique fondamental. Si \(L\) d√©pend de \(a\), qui d√©pend de \(z\), qui d√©pend de \(w\), alors :
                    </p>
                    <div class="math-block text-center">
                        $$ \frac{\partial L}{\partial w} = \frac{\partial L}{\partial a} \cdot \frac{\partial a}{\partial z} \cdot \frac{\partial z}{\partial w} $$
                    </div>
                    <p class="dl-text-muted text-xs mt-3">
                        On d√©compose un calcul complexe en une s√©rie de calculs simples, multipli√©s ensemble.
                    </p>
                </div>

                <h3 class="text-xl font-bold dl-text-primary mt-10 mb-4">Le Calcul √âtape par √âtape</h3>

                <div class="step-indicator">
                    <span class="step-number">1</span>
                    <span class="dl-text-primary font-semibold">Erreur de sortie</span>
                </div>
                <p class="mb-4 ml-10">
                    On commence par la fin. Pour la derni√®re couche :
                </p>
                <div class="math-block text-sm">
                    $$ \delta^{[L]} = \frac{\partial L}{\partial a^{[L]}} = -(y - \hat{y}) $$
                </div>

                <div class="step-indicator">
                    <span class="step-number">2</span>
                    <span class="dl-text-primary font-semibold">Propagation arri√®re de l'erreur</span>
                </div>
                <p class="mb-4 ml-10">
                    Pour chaque couche pr√©c√©dente, on "propage" l'erreur en arri√®re :
                </p>
                <div class="math-block text-sm">
                    $$ \delta^{[l]} = \delta^{[l+1]} \cdot W^{[l+1]} \cdot \sigma'(z^{[l]}) $$
                </div>
                <p class="mb-6 ml-10 text-sm dl-text-muted">
                    O√π \(\sigma'(z)\) est la d√©riv√©e de la fonction d'activation. Pour tanh : \(\sigma'(z) = 1 - \tanh^2(z)\).
                </p>

                <div class="step-indicator">
                    <span class="step-number">3</span>
                    <span class="dl-text-primary font-semibold">Calcul des gradients</span>
                </div>
                <p class="mb-4 ml-10">
                    Maintenant qu'on a les \(\delta\) pour chaque couche, on calcule le gradient pour chaque poids :
                </p>
                <div class="math-block text-sm">
                    $$ \frac{\partial L}{\partial W^{[l]}} = \delta^{[l]} \cdot (a^{[l-1]})^T $$
                    <p class="dl-text-muted text-xs mt-2">
                        Le gradient d'un poids = erreur locale √ó entr√©e de ce poids
                    </p>
                </div>

                <div class="analogy-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">üí°</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-2">Analogie : Le jeu du t√©l√©phone invers√©</h4>
                            <p class="dl-text-secondary text-sm">
                                Imaginez une file de personnes. Le dernier re√ßoit un message "tu t'es tromp√© de X". Il chuchote √† la personne devant lui "c'est en partie ta faute". Cette personne calcule sa part de responsabilit√© et transmet le message. √Ä la fin, chaque personne sait <strong>√† quel point elle a contribu√©</strong> √† l'erreur finale.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="warning-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">‚ö†Ô∏è</span>
                        <div>
                            <h4 class="font-bold text-yellow-500 mb-2">Pourquoi c'est efficace ?</h4>
                            <p class="dl-text-secondary text-sm">
                                L'alternative na√Øve serait de calculer la d√©riv√©e pour chaque poids <strong>ind√©pendamment</strong>, en faisant une forward pass √† chaque fois. Avec 1 million de poids, cela ferait 1 million de forward passes ! La backprop fait le m√™me travail en <strong>1 forward pass + 1 backward pass</strong>. C'est un gain de temps gigantesque.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHAPITRE 6: MISE √Ä JOUR DES POIDS -->
        <section id="optimizer" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">üîß</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 6 : La Descente de Gradient & Adam</h2>
            </div>

            <div class="prose-content dl-text-secondary">
                <p class="mb-6">
                    Maintenant qu'on a les gradients, on peut mettre √† jour les poids. La m√©thode la plus simple est la <strong>Descente de Gradient</strong> (Gradient Descent) :
                </p>

                <div class="math-block text-center">
                    $$ w_{t+1} = w_t - \eta \cdot \frac{\partial L}{\partial w} $$
                </div>

                <p class="mb-6">
                    O√π \(\eta\) est le <strong>taux d'apprentissage</strong> (learning rate). C'est la taille du pas qu'on fait √† chaque it√©ration.
                </p>

                <div class="grid md:grid-cols-2 gap-4 my-8">
                    <div class="bg-red-500/10 border border-red-500/30 p-4 rounded-xl">
                        <h4 class="font-bold text-red-400 mb-2">Œ∑ trop grand</h4>
                        <p class="text-sm dl-text-muted">On "saute" par-dessus le minimum, oscillation, divergence possible.</p>
                    </div>
                    <div class="bg-yellow-500/10 border border-yellow-500/30 p-4 rounded-xl">
                        <h4 class="font-bold text-yellow-500 mb-2">Œ∑ trop petit</h4>
                        <p class="text-sm dl-text-muted">Convergence tr√®s lente, risque de rester coinc√© dans un minimum local.</p>
                    </div>
                </div>

                <h3 class="text-xl font-bold dl-text-primary mt-10 mb-4">L'Optimiseur Adam</h3>

                <p class="mb-6">
                    La descente de gradient "vanilla" a des limitations. L'<strong>optimiseur Adam</strong> (Adaptive Moment Estimation) combine deux am√©liorations :
                </p>

                <div class="grid md:grid-cols-2 gap-6 my-8">
                    <div class="dl-card p-5 rounded-xl border">
                        <h4 class="font-bold text-purple-400 mb-3">Momentum</h4>
                        <p class="text-sm dl-text-muted mb-3">
                            Au lieu d'utiliser uniquement le gradient actuel, on utilise une <strong>moyenne mobile</strong> des gradients pass√©s. Cela "lisse" la trajectoire et acc√©l√®re la convergence.
                        </p>
                        <div class="math-block text-xs py-2">
                            $$ m_t = \beta_1 \cdot m_{t-1} + (1-\beta_1) \cdot g_t $$
                        </div>
                    </div>
                    <div class="dl-card p-5 rounded-xl border">
                        <h4 class="font-bold text-orange-400 mb-3">Taux Adaptatif</h4>
                        <p class="text-sm dl-text-muted mb-3">
                            Chaque poids a son propre learning rate qui s'ajuste en fonction de la <strong>variance de ses gradients</strong>. Un poids avec des gradients stables avance plus vite.
                        </p>
                        <div class="math-block text-xs py-2">
                            $$ v_t = \beta_2 \cdot v_{t-1} + (1-\beta_2) \cdot g_t^2 $$
                        </div>
                    </div>
                </div>

                <div class="analogy-box">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">‚öΩ</span>
                        <div>
                            <h4 class="font-bold text-green-400 mb-2">Analogie : La balle qui roule</h4>
                            <p class="dl-text-secondary text-sm">
                                Imaginez une balle qui roule dans une vall√©e. Le <strong>momentum</strong>, c'est son inertie : si elle roule toujours dans la m√™me direction, elle acc√©l√®re. Le <strong>taux adaptatif</strong>, c'est comme si la balle freinait automatiquement quand le terrain devient chaotique, mais acc√©l√©rait sur les lignes droites.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHAPITRE 7: HISTOIRE -->
        <section id="history" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">üìú</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 7 : Un Peu d'Histoire</h2>
            </div>

            <div class="prose-content dl-text-secondary">
                <p class="mb-8">
                    La r√©tropropagation n'est pas une invention soudaine, mais le fruit de d√©cennies de recherche en math√©matiques, th√©orie du contr√¥le, et informatique.
                </p>

                <div class="space-y-6">
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">1960s - A√©rospatiale</span>
                        <h3 class="text-lg font-semibold dl-text-primary">Kelley & Bryson</h3>
                        <p class="dl-text-muted mt-1 text-sm">Utilisent les gradients pour optimiser les trajectoires de fus√©es. Les bases math√©matiques existent d√©j√† !</p>
                    </div>
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">1970 - Diff√©rentiation Automatique</span>
                        <h3 class="text-lg font-semibold dl-text-primary">Seppo Linnainmaa</h3>
                        <p class="dl-text-muted mt-1 text-sm">Formalise le "mode inverse" de la diff√©rentiation automatique. C'est l'algorithme qui rend le calcul efficace.</p>
                    </div>
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">1974 - La Th√®se Oubli√©e</span>
                        <h3 class="text-lg font-semibold dl-text-primary">Paul Werbos</h3>
                        <p class="dl-text-muted mt-1 text-sm">Dans sa th√®se de PhD, il propose explicitement d'appliquer cela aux r√©seaux de neurones. Malheureusement, c'est l'√©poque de "l'hiver de l'IA" et personne n'y pr√™te attention.</p>
                    </div>
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">1986 - Le Triomphe</span>
                        <h3 class="text-lg font-semibold dl-text-primary">Rumelhart, Hinton & Williams</h3>
                        <p class="dl-text-muted mt-1 text-sm">Leur article dans <em>Nature</em> popularise enfin la technique. Ils montrent qu'un r√©seau peut apprendre des repr√©sentations internes, r√©solvant le fameux probl√®me XOR.</p>
                    </div>
                    <div class="history-card">
                        <span class="text-cyan-400 font-mono text-xs mb-1 block">2015 - L'√àre Moderne</span>
                        <h3 class="text-lg font-semibold dl-text-primary">Kingma & Ba</h3>
                        <p class="dl-text-muted mt-1 text-sm">Publication de l'optimiseur Adam, qui devient rapidement le standard pour entra√Æner les r√©seaux profonds.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- CHAPITRE 8: PI√àGES -->
        <section id="pitfalls" class="mb-24 scroll-mt-24">
            <div class="flex items-center gap-3 mb-6">
                <span class="text-3xl">‚ö†Ô∏è</span>
                <h2 class="text-3xl font-bold dl-text-primary">Chapitre 8 : Pi√®ges Classiques</h2>
            </div>

            <div class="grid md:grid-cols-2 gap-6">
                <div class="card-hover dl-card p-6 rounded-xl border">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-lg bg-red-500/20 flex items-center justify-center">üìâ</div>
                        <h3 class="text-lg font-bold dl-text-primary">Vanishing Gradient</h3>
                    </div>
                    <p class="text-sm dl-text-muted mb-4">
                        Dans les r√©seaux tr√®s profonds, les gradients se multiplient couche apr√®s couche. Si chaque d√©riv√©e est &lt; 1, le gradient devient minuscule et les premi√®res couches n'apprennent plus.
                    </p>
                    <div class="text-xs text-blue-400 font-mono">
                        Solutions : ReLU, Batch Normalization, ResNets
                    </div>
                </div>

                <div class="card-hover dl-card p-6 rounded-xl border">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-lg bg-purple-500/20 flex items-center justify-center">üï≥Ô∏è</div>
                        <h3 class="text-lg font-bold dl-text-primary">Minimums Locaux</h3>
                    </div>
                    <p class="text-sm dl-text-muted mb-4">
                        La descente de gradient peut rester coinc√©e dans un "creux" qui n'est pas le minimum global. En pratique, en haute dimension, c'est moins probl√©matique qu'on ne le pensait.
                    </p>
                    <div class="text-xs text-purple-400 font-mono">
                        Solutions : Momentum, Adam, Learning Rate Scheduling
                    </div>
                </div>

                <div class="card-hover dl-card p-6 rounded-xl border">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-lg bg-yellow-500/20 flex items-center justify-center">üìö</div>
                        <h3 class="text-lg font-bold dl-text-primary">Overfitting</h3>
                    </div>
                    <p class="text-sm dl-text-muted mb-4">
                        Le r√©seau "apprend par c≈ìur" les donn√©es d'entra√Ænement au lieu de g√©n√©raliser. Il performe bien sur les donn√©es vues, mais mal sur les nouvelles.
                    </p>
                    <div class="text-xs text-yellow-500 font-mono">
                        Solutions : Early Stopping, Dropout, Regularization
                    </div>
                </div>

                <div class="card-hover dl-card p-6 rounded-xl border">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-lg bg-orange-500/20 flex items-center justify-center">üí•</div>
                        <h3 class="text-lg font-bold dl-text-primary">Exploding Gradient</h3>
                    </div>
                    <p class="text-sm dl-text-muted mb-4">
                        L'inverse du vanishing : les gradients deviennent √©normes et font "exploser" les poids vers l'infini.
                    </p>
                    <div class="text-xs text-orange-400 font-mono">
                        Solutions : Gradient Clipping, Careful Initialization
                    </div>
                </div>
            </div>
        </section>

        <!-- SIMULATION LAB -->
        <section id="simulation" class="scroll-mt-16 mb-24">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-8 gap-4">
                <div class="flex items-center gap-3">
                    <span class="text-3xl">üß™</span>
                    <h2 class="text-3xl font-bold dl-text-primary">Laboratoire Interactif</h2>
                </div>
                <div class="flex gap-3 items-center">
                     <span class="text-xs dl-text-muted uppercase tracking-wide hidden sm:inline">Probl√®me:</span>
                     <select id="task-select" class="dl-select text-sm rounded-lg px-3 py-2 cursor-pointer border">
                        <option value="xor">XOR (Logique)</option>
                        <option value="circle">Cercle (Classification)</option>
                        <option value="sine">Sinus (R√©gression)</option>
                        <option value="spiral">Spirale (Complexe)</option>
                    </select>
                </div>
            </div>

            <p class="dl-text-muted mb-6">
                Mettez en pratique ce que vous avez appris ! Observez le r√©seau apprendre en temps r√©el. Les lignes jaunes indiquent les poids avec un fort gradient (qui changent beaucoup).
            </p>

            <!-- THE APP CONTAINER -->
            <div class="dl-bg-primary rounded-2xl border dl-border overflow-hidden shadow-2xl flex flex-col lg:flex-row min-h-[650px]">

                <!-- SIDEBAR CONTROLS -->
                <aside class="lab-sidebar w-full lg:w-72 border-r p-4 flex flex-col gap-4 overflow-y-auto">

                    <!-- Control Panel -->
                    <div class="lab-panel p-4 rounded-xl border space-y-4">
                        <div class="flex justify-between items-center">
                            <h3 class="text-xs font-bold dl-text-secondary uppercase tracking-wider">Contr√¥les</h3>
                            <div class="flex items-center gap-2">
                                <span id="status-text" class="text-[10px] dl-text-muted uppercase">Pr√™t</span>
                                <div class="w-2.5 h-2.5 rounded-full bg-slate-500" id="status-dot"></div>
                            </div>
                        </div>

                        <div class="flex items-center justify-between">
                            <div>
                                <label class="text-xs dl-text-secondary block">Rendu Visuel</label>
                                <p class="text-[10px] dl-text-muted">D√©sactiver = plus rapide</p>
                            </div>
                            <div id="render-toggle" class="toggle-switch active" data-active="true"></div>
                        </div>

                        <div class="flex items-center justify-between">
                            <div>
                                <label class="text-xs dl-text-secondary block">Auto-Stop</label>
                                <p class="text-[10px] dl-text-muted">Arr√™t si sur-apprentissage</p>
                            </div>
                            <div id="autostop-toggle" class="toggle-switch" data-active="false"></div>
                        </div>

                        <div>
                            <div class="flex justify-between text-xs dl-text-muted mb-2">
                                <span>Learning Rate (Œ∑)</span>
                                <span id="lr-val" class="text-blue-400 font-mono font-semibold">0.01</span>
                            </div>
                            <input type="range" id="lr-input" min="0.001" max="0.1" step="0.001" value="0.01" class="dl-input w-full h-1.5 rounded-lg appearance-none cursor-pointer accent-blue-500">
                        </div>

                        <div class="grid grid-cols-2 gap-2 pt-2">
                            <button id="btn-train" class="col-span-2 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 text-white py-2.5 rounded-lg text-sm font-bold transition-all shadow-lg shadow-blue-900/30 flex items-center justify-center gap-2">
                                <span>D√âMARRER</span>
                            </button>
                            <button id="btn-reset" class="dl-bg-tertiary hover:opacity-80 dl-text-primary py-2 rounded-lg text-xs font-medium transition border dl-border">Reset</button>
                            <button id="btn-step" class="dl-bg-tertiary hover:opacity-80 dl-text-primary py-2 rounded-lg text-xs font-medium transition border dl-border">+1 Epoch</button>
                        </div>
                    </div>

                    <!-- Stats Panel -->
                    <div class="lab-panel p-4 rounded-xl border flex-grow flex flex-col min-h-[250px]">
                        <h3 class="text-xs font-bold dl-text-secondary uppercase tracking-wider mb-3">M√©triques</h3>
                        <div class="grid grid-cols-2 gap-2 mb-3">
                            <div class="lab-metric p-2 rounded-lg border">
                                <span class="text-[10px] dl-text-muted block">Epochs</span>
                                <span id="metric-epoch" class="text-sm font-mono dl-text-primary font-bold">0</span>
                            </div>
                            <div class="lab-metric p-2 rounded-lg border">
                                <span class="text-[10px] dl-text-muted block">Train Loss</span>
                                <span id="metric-loss" class="text-sm font-mono text-red-400 font-bold">0.000</span>
                            </div>
                            <div class="lab-metric p-2 rounded-lg border">
                                <span class="text-[10px] dl-text-muted block">Val Loss</span>
                                <span id="metric-val-loss" class="text-sm font-mono text-yellow-500 font-bold">0.000</span>
                            </div>
                            <div class="lab-metric p-2 rounded-lg border relative">
                                <span class="text-[10px] dl-text-muted block">Best Val</span>
                                <span id="metric-best-loss" class="text-sm font-mono text-green-400 font-bold">‚àû</span>
                                <div id="overfit-indicator" class="absolute top-1 right-1 hidden">
                                    <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse" title="Sur-apprentissage"></div>
                                </div>
                            </div>
                        </div>

                        <div class="flex-grow min-h-[80px] relative">
                            <canvas id="lossChart"></canvas>
                        </div>
                        <div class="flex justify-center gap-4 mt-2 text-[10px] dl-text-muted">
                            <span class="flex items-center gap-1"><span class="w-3 h-0.5 bg-red-400 rounded"></span> Train</span>
                            <span class="flex items-center gap-1"><span class="w-3 h-0.5 bg-yellow-400 rounded"></span> Val</span>
                        </div>
                    </div>

                    <div class="text-[11px] text-center dl-text-muted font-mono dl-bg-tertiary rounded-lg py-2 px-3 border dl-border">
                        Arch: <span id="arch-display" class="dl-text-secondary">...</span>
                    </div>
                </aside>

                <!-- VISUALIZATION AREA -->
                <div class="lab-vis-area flex-grow flex flex-col md:flex-row relative">
                    <div class="flex-1 border-b md:border-b-0 md:border-r dl-border relative overflow-hidden min-h-[250px]">
                        <div class="absolute top-3 left-3 z-10 dl-bg-secondary px-3 py-1.5 rounded-lg text-[11px] font-bold dl-text-secondary border dl-border backdrop-blur-sm pointer-events-none">
                            R√©seau (Forward ‚Üí, Backprop ‚Üê)
                        </div>
                        <canvas id="networkCanvas" class="w-full h-full"></canvas>
                    </div>

                    <div class="flex-1 relative overflow-hidden min-h-[250px]">
                        <div class="absolute top-3 left-3 z-10 dl-bg-secondary px-3 py-1.5 rounded-lg text-[11px] font-bold dl-text-secondary border dl-border backdrop-blur-sm pointer-events-none">
                            Pr√©dictions du r√©seau
                        </div>
                        <canvas id="visCanvas" class="w-full h-full"></canvas>

                        <div id="fast-mode-overlay" class="lab-overlay absolute inset-0 backdrop-blur-sm flex items-center justify-center hidden">
                            <div class="text-center">
                                <div class="w-10 h-10 border-4 border-yellow-400/30 border-t-yellow-400 rounded-full animate-spin mx-auto mb-3"></div>
                                <div class="text-yellow-500 font-bold">Mode Rapide</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CONCLUSION -->
        <section id="conclusion" class="mb-16">
            <div class="concept-box">
                <h3 class="text-xl font-bold dl-text-primary mb-4">R√©sum√©</h3>
                <ol class="list-decimal list-inside space-y-3 dl-text-secondary">
                    <li><strong>Forward Pass</strong> : L'entr√©e traverse le r√©seau couche par couche pour produire une pr√©diction.</li>
                    <li><strong>Fonction de Perte</strong> : Mesure l'√©cart entre la pr√©diction et la vraie r√©ponse.</li>
                    <li><strong>Backpropagation</strong> : Utilise la r√®gle de la cha√Æne pour calculer la "responsabilit√©" de chaque poids dans l'erreur.</li>
                    <li><strong>Mise √† jour</strong> : L'optimiseur (Adam) ajuste les poids dans la direction qui r√©duit l'erreur.</li>
                    <li><strong>R√©p√©ter</strong> : On recommence jusqu'√† convergence (ou sur-apprentissage !).</li>
                </ol>
            </div>
        </section>

    </main>

    <!-- Toast -->
    <div id="toast" class="toast">
        <div class="dl-bg-secondary border dl-border rounded-xl shadow-2xl p-4 flex items-center gap-3 max-w-sm">
            <div id="toast-icon" class="w-10 h-10 rounded-full bg-green-500/20 flex items-center justify-center flex-shrink-0">
                <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
            </div>
            <div>
                <div id="toast-title" class="dl-text-primary font-semibold text-sm">Early Stop</div>
                <div id="toast-message" class="dl-text-muted text-xs">Convergence atteinte</div>
            </div>
            <button onclick="hideToast()" class="dl-text-muted hover:opacity-70 ml-2">‚úï</button>
        </div>
    </div>

    <footer class="dl-footer border-t py-8 text-center text-sm">
        <p>Cours g√©n√©r√© pour expliquer les fondamentaux du Deep Learning</p>
    </footer>

    <script>
        /**
         * Laboratoire interactif de Deep Learning
         * Impl√©mentation d'un r√©seau de neurones avec backpropagation et Adam
         */

        // --- HELPERS ---
        const tanh = Math.tanh;
        const rand = (min, max) => Math.random() * (max - min) + min;
        const shuffle = (arr) => arr.sort(() => Math.random() - 0.5);

        // --- TOAST ---
        function showToast(title, message) {
            document.getElementById('toast-title').textContent = title;
            document.getElementById('toast-message').textContent = message;
            document.getElementById('toast').classList.add('show');
            setTimeout(() => hideToast(), 4000);
        }
        function hideToast() { document.getElementById('toast').classList.remove('show'); }

        // --- NEURAL NETWORK with Adam ---
        class DeepNeuralNetwork {
            constructor(layerSizes, lr = 0.01) {
                this.layerSizes = layerSizes;
                this.layers = [];
                this.lr = lr;
                this.beta1 = 0.9;
                this.beta2 = 0.999;
                this.epsilon = 1e-8;
                this.t = 0;

                for (let i = 0; i < layerSizes.length - 1; i++) {
                    const inSize = layerSizes[i], outSize = layerSizes[i+1];
                    const limit = Math.sqrt(6 / (inSize + outSize));
                    this.layers.push({
                        weights: new Float32Array(inSize * outSize).map(() => rand(-limit, limit)),
                        biases: new Float32Array(outSize).fill(0.01),
                        mW: new Float32Array(inSize * outSize).fill(0),
                        vW: new Float32Array(inSize * outSize).fill(0),
                        mB: new Float32Array(outSize).fill(0),
                        vB: new Float32Array(outSize).fill(0),
                        inputs: null, outputs: null, gradients: null,
                        inSize, outSize
                    });
                }
            }

            forward(input) {
                let curr = Float32Array.from(input);
                for(let l of this.layers) {
                    l.inputs = curr;
                    let next = new Float32Array(l.outSize);
                    for(let j=0; j<l.outSize; j++) {
                        let sum = l.biases[j];
                        for(let k=0; k<l.inSize; k++) sum += curr[k] * l.weights[k * l.outSize + j];
                        next[j] = tanh(sum);
                    }
                    l.outputs = next;
                    curr = next;
                }
                return curr;
            }

            train(input, target) {
                const output = this.forward(input);
                this.t++;

                let errors = new Float32Array(output.length);
                let loss = 0;
                for(let i=0; i<output.length; i++) {
                    const diff = target[i] - output[i];
                    errors[i] = diff;
                    loss += diff * diff;
                }

                for(let i=this.layers.length-1; i>=0; i--) {
                    const l = this.layers[i];
                    const nextErrors = new Float32Array(l.inSize);
                    const gradients = new Float32Array(l.outSize);

                    for(let j=0; j<l.outSize; j++) {
                        const dtanh = 1 - l.outputs[j] * l.outputs[j];
                        const grad = errors[j] * dtanh;
                        gradients[j] = grad;

                        l.mB[j] = this.beta1 * l.mB[j] + (1 - this.beta1) * grad;
                        l.vB[j] = this.beta2 * l.vB[j] + (1 - this.beta2) * grad * grad;
                        const mBHat = l.mB[j] / (1 - Math.pow(this.beta1, this.t));
                        const vBHat = l.vB[j] / (1 - Math.pow(this.beta2, this.t));
                        l.biases[j] += this.lr * mBHat / (Math.sqrt(vBHat) + this.epsilon);

                        for(let k=0; k<l.inSize; k++) {
                            const wIdx = k * l.outSize + j;
                            nextErrors[k] += errors[j] * l.weights[wIdx] * dtanh;
                            const wGrad = grad * l.inputs[k];
                            l.mW[wIdx] = this.beta1 * l.mW[wIdx] + (1 - this.beta1) * wGrad;
                            l.vW[wIdx] = this.beta2 * l.vW[wIdx] + (1 - this.beta2) * wGrad * wGrad;
                            const mWHat = l.mW[wIdx] / (1 - Math.pow(this.beta1, this.t));
                            const vWHat = l.vW[wIdx] / (1 - Math.pow(this.beta2, this.t));
                            l.weights[wIdx] += this.lr * mWHat / (Math.sqrt(vWHat) + this.epsilon);
                        }
                    }
                    l.gradients = gradients;
                    errors = nextErrors;
                }
                return loss / output.length;
            }

            evaluate(dataset) {
                let totalLoss = 0;
                for(const d of dataset) {
                    const out = this.forward(d.i);
                    for(let i = 0; i < out.length; i++) totalLoss += (d.t[i] - out[i]) ** 2;
                }
                return totalLoss / dataset.length;
            }
        }

        // --- TASKS (optimized from hyperparameter search) ---
        const TASKS = {
            'xor': { arch: [2, 8, 4, 1], type: 'classif', defaultLR: 0.05,
                gen: () => { let d = []; for(let i=0; i<20; i++) { d.push({i:[-0.9+rand(-0.1,0.1),-0.9+rand(-0.1,0.1)],t:[-0.9]}); d.push({i:[-0.9+rand(-0.1,0.1),0.9+rand(-0.1,0.1)],t:[0.9]}); d.push({i:[0.9+rand(-0.1,0.1),-0.9+rand(-0.1,0.1)],t:[0.9]}); d.push({i:[0.9+rand(-0.1,0.1),0.9+rand(-0.1,0.1)],t:[-0.9]}); } return d; }
            },
            'circle': { arch: [2, 16, 8, 1], type: 'classif', defaultLR: 0.03,
                gen: () => { let d = []; for(let i=0; i<120; i++) { let x=rand(-1,1), y=rand(-1,1); d.push({i:[x,y], t:[(x*x+y*y<0.4)?0.9:-0.9]}); } return d; }
            },
            'sine': { arch: [1, 32, 32, 1], type: 'reg', defaultLR: 0.01,
                gen: () => { let d = []; for(let i=0; i<100; i++) { let x=rand(-1,1); d.push({i:[x], t:[Math.sin(x*Math.PI)]}); } return d; }
            },
            'spiral': { arch: [2, 64, 32, 1], type: 'classif', defaultLR: 0.01,
                gen: () => { let d = []; const N=150; for(let i=0; i<N; i++) { let r=(i/N)*0.95+0.05, t=1.75*i/N*2*Math.PI+rand(-0.1,0.1); let noise=()=>rand(-0.02,0.02); d.push({i:[r*Math.sin(t)+noise(),r*Math.cos(t)+noise()],t:[0.9]}); d.push({i:[r*Math.sin(t+Math.PI)+noise(),r*Math.cos(t+Math.PI)+noise()],t:[-0.9]}); } return d; }
            }
        };

        // --- STATE ---
        let dnn, trainData, valData, taskType, animationId;
        let isTraining = false, epoch = 0, fastMode = false, autoStopEnabled = false;
        const PATIENCE = 200;
        let bestValLoss = Infinity, epochsWithoutImprovement = 0;

        const cNet = document.getElementById('networkCanvas');
        const cVis = document.getElementById('visCanvas');
        const ctxNet = cNet.getContext('2d');
        const ctxVis = cVis.getContext('2d');

        let chart = new Chart(document.getElementById('lossChart').getContext('2d'), {
            type: 'line',
            data: { labels: [], datasets: [
                { label: 'Train', data: [], borderColor: '#f87171', borderWidth: 2, pointRadius: 0, tension: 0.3 },
                { label: 'Val', data: [], borderColor: '#fbbf24', borderWidth: 2, pointRadius: 0, tension: 0.3 }
            ]},
            options: { responsive: true, maintainAspectRatio: false, animation: false,
                scales: { x: {display:false}, y: {display:true, grid:{color:'#334155'}, ticks:{color:'#64748b',font:{size:10}}, min:0} },
                plugins: { legend: {display:false} }
            }
        });

        function setupToggle(id, onChange) {
            const t = document.getElementById(id);
            t.addEventListener('click', () => {
                const active = t.dataset.active === 'true';
                t.dataset.active = (!active).toString();
                t.classList.toggle('active', !active);
                onChange(!active);
            });
        }
        setupToggle('render-toggle', (a) => { fastMode = !a; });
        setupToggle('autostop-toggle', (a) => { autoStopEnabled = a; });

        function init(taskName) {
            isTraining = false; cancelAnimationFrame(animationId);
            const btn = document.getElementById('btn-train');
            btn.innerHTML = '<span>D√âMARRER</span>';
            btn.classList.remove('from-red-600','to-red-500'); btn.classList.add('from-blue-600','to-blue-500');
            document.getElementById('status-dot').className = "w-2.5 h-2.5 rounded-full bg-slate-500";
            document.getElementById('status-text').textContent = "Pr√™t";
            document.getElementById('overfit-indicator').classList.add('hidden');
            document.getElementById('fast-mode-overlay').classList.add('hidden');

            const t = TASKS[taskName];
            dnn = new DeepNeuralNetwork(t.arch, t.defaultLR);
            document.getElementById('lr-input').value = t.defaultLR;
            document.getElementById('lr-val').textContent = t.defaultLR;

            const allData = shuffle(t.gen());
            const splitIdx = Math.floor(allData.length * 0.8);
            trainData = allData.slice(0, splitIdx);
            valData = allData.slice(splitIdx);
            taskType = t.type;
            document.getElementById('arch-display').textContent = t.arch.join(' ‚Üí ');

            epoch = 0; bestValLoss = Infinity; epochsWithoutImprovement = 0;
            chart.data.labels = []; chart.data.datasets[0].data = []; chart.data.datasets[1].data = [];
            chart.update();
            updateMetrics(0, 0);
            document.getElementById('metric-best-loss').textContent = '‚àû';
            resize(); drawNet(); drawVis();
        }

        function resize() {
            [cNet, cVis].forEach(c => {
                const dpr = window.devicePixelRatio || 1;
                c.width = c.clientWidth * dpr; c.height = c.clientHeight * dpr;
                c.getContext('2d').scale(dpr, dpr);
            });
        }
        window.onresize = () => { resize(); if(!isTraining) { drawNet(); drawVis(); } };

        function loop() {
            if(!isTraining) return;
            fastMode = document.getElementById('render-toggle').dataset.active !== 'true';
            document.getElementById('fast-mode-overlay').classList.toggle('hidden', !fastMode);

            let steps = fastMode ? 50 : 5, totalLoss = 0;
            for(let k=0; k<steps; k++) { let idx = Math.floor(Math.random()*trainData.length); totalLoss += dnn.train(trainData[idx].i, trainData[idx].t); }
            epoch += steps;
            let avgTrainLoss = totalLoss / steps, valLoss = dnn.evaluate(valData);

            const isOverfitting = checkOverfitting(valLoss);
            updateMetrics(avgTrainLoss, valLoss);
            if (!fastMode) { drawNet(); if(epoch % 10 === 0) drawVis(); }
            if (isOverfitting && autoStopEnabled) { stopTraining(true); return; }
            animationId = requestAnimationFrame(loop);
        }

        function checkOverfitting(valLoss) {
            const ind = document.getElementById('overfit-indicator');
            if (valLoss < bestValLoss * 0.999) { bestValLoss = valLoss; epochsWithoutImprovement = 0; document.getElementById('metric-best-loss').textContent = bestValLoss.toFixed(4); ind.classList.add('hidden'); return false; }
            epochsWithoutImprovement += (fastMode ? 50 : 5);
            if (epochsWithoutImprovement > PATIENCE / 3) ind.classList.remove('hidden');
            return epochsWithoutImprovement >= PATIENCE;
        }

        function stopTraining(autoStopped = false) {
            isTraining = false; cancelAnimationFrame(animationId);
            const btn = document.getElementById('btn-train');
            btn.innerHTML = '<span>REPRENDRE</span>';
            btn.classList.remove('from-red-600','to-red-500'); btn.classList.add('from-blue-600','to-blue-500');
            document.getElementById('status-dot').className = "w-2.5 h-2.5 rounded-full bg-yellow-500";
            document.getElementById('status-text').textContent = autoStopped ? "Stopp√©" : "Pause";
            document.getElementById('fast-mode-overlay').classList.add('hidden');
            if (autoStopped) showToast('Early Stop', `Convergence apr√®s ${epoch} epochs`);
            drawNet(); drawVis();
        }

        function updateMetrics(trainLoss, valLoss) {
            document.getElementById('metric-epoch').innerText = epoch.toLocaleString();
            document.getElementById('metric-loss').innerText = trainLoss.toFixed(4);
            document.getElementById('metric-val-loss').innerText = valLoss.toFixed(4);
            const freq = fastMode ? 100 : 20;
            if (epoch % freq === 0) {
                chart.data.labels.push(epoch); chart.data.datasets[0].data.push(trainLoss); chart.data.datasets[1].data.push(valLoss);
                if(chart.data.labels.length > 60) { chart.data.labels.shift(); chart.data.datasets[0].data.shift(); chart.data.datasets[1].data.shift(); }
                chart.update();
            }
        }

        function drawNet() {
            const w = cNet.clientWidth, h = cNet.clientHeight, ctx = ctxNet;
            ctx.clearRect(0, 0, w, h);
            const layerCounts = dnn.layerSizes, maxDisplay = 10;
            const displayCounts = layerCounts.map(c => Math.min(c, maxDisplay));
            const padding = { x: w * 0.12, y: h * 0.12 };
            const layerX = displayCounts.map((_, i) => padding.x + (i * (w - 2*padding.x) / (displayCounts.length - 1)));
            const nodePos = displayCounts.map((count) => { let step = Math.min((h - 2*padding.y) / count, 35); return Array(count).fill(0).map((_, j) => (h / 2) - ((count-1)*step/2) + (j*step)); });

            ctx.globalAlpha = 0.5;
            for(let i=0; i<dnn.layers.length; i++) {
                const l = dnn.layers[i];
                const srcCount = Math.min(l.inSize, maxDisplay), dstCount = Math.min(l.outSize, maxDisplay);
                for(let src=0; src<srcCount; src++) {
                    for(let dst=0; dst<dstCount; dst++) {
                        const actualSrc = Math.floor(src * l.inSize / srcCount), actualDst = Math.floor(dst * l.outSize / dstCount);
                        let weight = l.weights[actualSrc * l.outSize + actualDst];
                        let grad = l.gradients ? l.gradients[actualDst] : 0;
                        ctx.beginPath(); ctx.moveTo(layerX[i], nodePos[i][src]); ctx.lineTo(layerX[i+1], nodePos[i+1][dst]);
                        if(isTraining && Math.abs(grad) > 0.02 && !fastMode) { ctx.strokeStyle = `rgba(250, 204, 21, ${Math.min(1, Math.abs(grad)*15)})`; ctx.lineWidth = 2; }
                        else { const intensity = Math.min(1, Math.abs(weight) * 0.8); ctx.strokeStyle = weight > 0 ? `rgba(59, 130, 246, ${intensity})` : `rgba(239, 68, 68, ${intensity})`; ctx.lineWidth = Math.max(0.5, Math.min(2.5, Math.abs(weight)*2)); }
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1;
            for(let i=0; i<displayCounts.length; i++) {
                for(let j=0; j<displayCounts[i]; j++) {
                    const x = layerX[i], y = nodePos[i][j];
                    ctx.beginPath(); ctx.arc(x, y, 7, 0, Math.PI*2); ctx.fillStyle = '#1e293b'; ctx.fill();
                    let val = 0; if(i > 0) { const actualJ = Math.floor(j * layerCounts[i] / displayCounts[i]); val = dnn.layers[i-1].outputs ? dnn.layers[i-1].outputs[actualJ] : 0; }
                    ctx.strokeStyle = val > 0 ? '#60a5fa' : '#f87171'; ctx.lineWidth = 2; ctx.stroke();
                }
                if(layerCounts[i] > maxDisplay) { ctx.fillStyle = '#64748b'; ctx.font = '9px Monaco, monospace'; ctx.textAlign = 'center'; ctx.fillText(`+${layerCounts[i] - maxDisplay}`, layerX[i], h - 8); }
            }
        }

        function drawVis() {
            const w = cVis.clientWidth, h = cVis.clientHeight, ctx = ctxVis;
            ctx.clearRect(0, 0, w, h);
            if (taskType === 'classif') {
                const res = 35, cellW = w/res, cellH = h/res;
                for(let i=0; i<res; i++) { for(let j=0; j<res; j++) { let x = (i/res)*2.4-1.2, y = (j/res)*2.4-1.2, out = dnn.forward([x,y])[0]; let r=0, g=0, b=0; if(out>0){b=Math.floor(Math.min(1,out)*180);g=30;}else{r=Math.floor(Math.min(1,Math.abs(out))*180);g=20;} ctx.fillStyle=`rgba(${r},${g},${b},0.4)`; ctx.fillRect(i*cellW,j*cellH,cellW+1,cellH+1); }}
                trainData.forEach(p => { let px=((p.i[0]+1.2)/2.4)*w, py=((p.i[1]+1.2)/2.4)*h; ctx.beginPath(); ctx.arc(px,py,4,0,Math.PI*2); ctx.fillStyle=p.t[0]>0?'#3b82f6':'#ef4444'; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke(); });
                valData.forEach(p => { let px=((p.i[0]+1.2)/2.4)*w, py=((p.i[1]+1.2)/2.4)*h; ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2); ctx.strokeStyle='#fbbf24'; ctx.lineWidth=1.5; ctx.stroke(); });
            } else {
                ctx.strokeStyle='#fbbf24'; ctx.lineWidth=3; ctx.shadowColor='#fbbf24'; ctx.shadowBlur=8; ctx.beginPath();
                for(let px=0;px<w;px+=3){ let x=(px/w)*2-1, y=dnn.forward([x])[0], py=h/2-(y*h*0.4); if(px===0)ctx.moveTo(px,py);else ctx.lineTo(px,py); } ctx.stroke(); ctx.shadowBlur=0;
                ctx.strokeStyle='rgba(100,116,139,0.4)'; ctx.lineWidth=1; ctx.setLineDash([4,4]); ctx.beginPath();
                for(let px=0;px<w;px+=3){ let x=(px/w)*2-1, y=Math.sin(x*Math.PI), py=h/2-(y*h*0.4); if(px===0)ctx.moveTo(px,py);else ctx.lineTo(px,py); } ctx.stroke(); ctx.setLineDash([]);
                trainData.forEach(p => { let px=((p.i[0]+1)/2)*w, py=h/2-(p.t[0]*h*0.4); ctx.beginPath(); ctx.arc(px,py,4,0,Math.PI*2); ctx.fillStyle='#3b82f6'; ctx.fill(); });
                valData.forEach(p => { let px=((p.i[0]+1)/2)*w, py=h/2-(p.t[0]*h*0.4); ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2); ctx.strokeStyle='#fbbf24'; ctx.lineWidth=1.5; ctx.stroke(); });
                ctx.strokeStyle='#334155'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();
            }
        }

        document.getElementById('task-select').onchange = (e) => init(e.target.value);
        document.getElementById('lr-input').oninput = (e) => { dnn.lr = parseFloat(e.target.value); document.getElementById('lr-val').innerText = dnn.lr.toFixed(3); };
        document.getElementById('btn-train').onclick = () => {
            isTraining = !isTraining;
            if(isTraining) { epochsWithoutImprovement = 0; const btn = document.getElementById('btn-train'); btn.innerHTML = '<span>PAUSE</span>'; btn.classList.remove('from-blue-600','to-blue-500'); btn.classList.add('from-red-600','to-red-500'); document.getElementById('status-dot').className = "w-2.5 h-2.5 rounded-full bg-green-500 animate-pulse"; document.getElementById('status-text').textContent = "Training"; loop(); }
            else { stopTraining(false); }
        };
        document.getElementById('btn-reset').onclick = () => init(document.getElementById('task-select').value);
        document.getElementById('btn-step').onclick = () => { if(isTraining) stopTraining(false); let totalLoss=0; shuffle(trainData); trainData.forEach(d=>{totalLoss+=dnn.train(d.i,d.t);}); epoch+=trainData.length; const trainLoss=totalLoss/trainData.length, valLoss=dnn.evaluate(valData); checkOverfitting(valLoss); updateMetrics(trainLoss,valLoss); drawNet(); drawVis(); };

        init('xor');
    </script>
</body>
</html>
